package abi

// Code autogenerated. DO NOT EDIT.

var contractErrors = map[ContractInterface]map[int32]string{
	MultisigOrderV2: {104: "Unauthorized init",
		105:   "Already inited",
		106:   "Unauthorized sign",
		107:   "Already approved",
		111:   "Expired",
		112:   "Already executed",
		65535: "Unknown op",
	},
	MultisigV2: {100: "Not enough ton",
		101:  "Unauthorized execute",
		102:  "Signers outdated",
		103:  "Invalid dictionary sequence",
		108:  "Inconsistent data",
		109:  "Invalid threshold",
		110:  "Invalid signers",
		111:  "Expired",
		1007: "Unauthorized proposer",
		1008: "Invalid new order",
	},
	WalletV4R2: {33: "Invalid seqno",
		34: "Invalid subwallet ID",
		35: "Invalid signature",
		36: "Expired message",
		39: "Plugin not found",
		80: "Not enough ton",
	},
}

var defaultExitCodes = map[int32]string{
	0:   "Ok",
	1:   "Ok",
	2:   "Stack underflow",
	3:   "Stack overflow",
	4:   "Integer overflow or division by zero",
	5:   "Integer out of expected range",
	6:   "Invalid opcode",
	7:   "Type check error",
	8:   "Cell overflow",
	9:   "Cell underflow",
	10:  "Dictionary error",
	11:  "Unknown error",
	12:  "Impossible situation error",
	13:  "Out of gas error",
	-14: "Out of gas error",
}

func GetContractError(interfaces []ContractInterface, code int32) *string {
	errors := defaultExitCodes
	for _, i := range interfaces {
		e, ok := contractErrors[i]
		if ok {
			errors = e
			break
		}
	}
	if msg, ok := errors[code]; ok {
		return &msg
	}
	return nil
}
