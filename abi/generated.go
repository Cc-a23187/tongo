package abi

// Code autogenerated. DO NOT EDIT.

import (
	"context"
	"fmt"
	"github.com/tonkeeper/tongo"
	"github.com/tonkeeper/tongo/boc"
	"github.com/tonkeeper/tongo/tlb"
)

type ClosingConfig struct {
	QuarantinDuration        uint32
	MisbehaviorFine          tlb.Grams
	ConditionalCloseDuration uint32
}

type ConditionalPayment struct {
	Amount    tlb.Grams
	Condition tlb.Any
}

type PaymentConfig struct {
	ExcessFee tlb.Grams
	DestA     tlb.MsgAddress
	DestB     tlb.MsgAddress
}

type QuarantinedState struct {
	StateA           SemiChannelBody
	StateB           SemiChannelBody
	QuarantineStarts uint32
	StateCommitedByA bool
}

type SemiChannel struct {
	Magic            tlb.Magic `tlb:"#43685374"`
	ChannelId        tlb.Uint128
	Data             SemiChannelBody
	CounterpartyData tlb.Maybe[tlb.Ref[SemiChannelBody]]
}

type SemiChannelBody struct {
	Seqno        uint64
	Sent         tlb.Grams
	Conditionals tlb.HashmapE[tlb.Uint32, ConditionalPayment]
}

type SignedSemiChannel struct {
	Signature tlb.Bits512
	State     SemiChannel
}

type Storage struct {
	BalanceA       tlb.Grams
	BalanceB       tlb.Grams
	KeyA           tlb.Uint256
	KeyB           tlb.Uint256
	ChannelId      tlb.Uint128
	Config         tlb.Ref[ClosingConfig]
	CommitedSeqnoA uint32
	CommitedSeqnoB uint32
	Quarantin      tlb.Maybe[tlb.Ref[QuarantinedState]]
	Payments       tlb.Ref[PaymentConfig]
}

type TorrentInfo struct {
	PieceSize      uint32
	FileSize       uint64
	RootHash       tlb.Uint256
	HeaderSize     uint64
	HeaderHash     tlb.Uint256
	MicrochunkHash tlb.Maybe[tlb.Uint256]
	Description    tlb.Text
}

type NftRoyaltyParams struct {
	Numerator   uint16
	Denominator uint16
	Destination tlb.MsgAddress
}

type TeleitemAuctionConfig struct {
	BeneficiarAddress tlb.MsgAddress
	InitialMinBid     tlb.Grams
	MaxBid            tlb.Grams
	MinBidStep        uint8
	MinExtendTime     uint32
	Duration          uint32
}

type TelemintData struct {
	Touched           bool
	SubwalletId       uint32
	PublicKey         tlb.Bits256
	CollectionContent tlb.Ref[tlb.Any]
	NftItemCode       tlb.Ref[tlb.Any]
	RoyaltyParams     tlb.Ref[NftRoyaltyParams]
}

type TelemintRestrictions struct {
	ForceSenderAddress   tlb.Maybe[tlb.MsgAddress]
	RewriteSenderAddress tlb.Maybe[tlb.MsgAddress]
}

type TelemintUnsignedDeploy struct {
	SubwalletId   uint32
	ValidSince    uint32
	ValidTill     uint32
	Username      tlb.FixedLengthText
	Content       tlb.Ref[tlb.Any]
	AuctionConfig tlb.Ref[TeleitemAuctionConfig]
	RoyaltyParams tlb.Maybe[tlb.Ref[NftRoyaltyParams]]
}

type TelemintUnsignedDeployV2 struct {
	SubwalletId   uint32
	ValidSince    uint32
	ValidTill     uint32
	TokenName     tlb.FixedLengthText
	Content       tlb.Ref[tlb.Any]
	AuctionConfig tlb.Ref[TeleitemAuctionConfig]
	RoyaltyParams tlb.Maybe[tlb.Ref[NftRoyaltyParams]]
	Restrictions  tlb.Maybe[tlb.Ref[TelemintRestrictions]]
}

type WhalesNominatorsMember struct {
	ProfitPerCoin      tlb.Int128
	Balance            tlb.Grams
	PendingWithdraw    tlb.Grams
	PendingWithdrawAll bool
	PendingDeposit     tlb.Grams
	MemberWithdraw     tlb.Grams
}

type WhalesNominatorsMembersList struct {
	List tlb.Hashmap[tlb.Bits256, WhalesNominatorsMember]
}

type AccountLists struct {
	List tlb.Hashmap[tlb.Bits256, tlb.Any]
}

type TextCommentMsgBody struct {
	Text tlb.Text
}

type ProveOwnershipMsgBody struct {
	QueryId        uint64
	Dest           tlb.MsgAddress
	ForwardPayload tlb.Ref[tlb.Any]
	WithContent    bool
}

type NftOwnershipAssignedMsgBody struct {
	QueryId        uint64
	PrevOwner      tlb.MsgAddress
	ForwardPayload tlb.EitherRef[tlb.Any]
}

type OwnershipProofMsgBody struct {
	QueryId   uint64
	ItemId    tlb.Uint256
	Owner     tlb.MsgAddress
	Data      tlb.Ref[tlb.Any]
	RevokedAt uint64
	Content   tlb.Maybe[tlb.Ref[tlb.Any]]
}

type ChallengeQuarantinedChannelStateMsgBody struct {
	ChallengedByA bool
	Signature     tlb.Bits512
	Tag           uint32
	ChannelId     tlb.Uint128
	SchA          tlb.Ref[SignedSemiChannel]
	SchB          tlb.Ref[SignedSemiChannel]
}

type SbtOwnerInfoMsgBody struct {
	QueryId   uint64
	ItemId    tlb.Uint256
	Initiator tlb.MsgAddress
	Owner     tlb.MsgAddress
	Data      tlb.Ref[tlb.Any]
	RevokedAt uint64
	Content   tlb.Maybe[tlb.Ref[tlb.Any]]
}

type InitPaymentChannelMsgBody struct {
	IsA       bool
	Signature tlb.Bits512
	Tag       uint32
	ChannelId tlb.Uint128
	BalanceA  tlb.Grams
	BalanceB  tlb.Grams
}

type JettonTransferMsgBody struct {
	QueryId             uint64
	Amount              tlb.VarUInteger16
	Destination         tlb.MsgAddress
	ResponseDestination tlb.MsgAddress
	CustomPayload       tlb.Maybe[tlb.Ref[tlb.Any]]
	ForwardTonAmount    tlb.VarUInteger16
	ForwardPayload      tlb.EitherRef[tlb.Any]
}

type OfferStorageContractMsgBody struct {
	QueryId uint64
}

type TonstakeControllerPoolHaltMsgBody struct {
	QueryId uint64
}

type TonstakeControllerCreditMsgBody struct {
	QueryId uint64
	Amount  tlb.Grams
}

type JettonInternalTransferMsgBody struct {
	QueryId          uint64
	Amount           tlb.VarUInteger16
	From             tlb.MsgAddress
	ResponseAddress  tlb.MsgAddress
	ForwardTonAmount tlb.VarUInteger16
}

type SbtDestroyMsgBody struct {
	QueryId uint64
}

type StartUncooperativeChannelCloseMsgBody struct {
	SignedByA bool
	Signature tlb.Bits512
	Tag       uint32
	ChannelId tlb.Uint128
	SchA      tlb.Ref[SignedSemiChannel]
	SchB      tlb.Ref[SignedSemiChannel]
}

type FinishUncooperativeChannelCloseMsgBody struct{}

type TonstakeControllerPoolSendMessageMsgBody struct {
	QueryId uint64
	Mode    uint8
	Msg     tlb.Ref[tlb.Any]
}

type TeleitemDeployMsgBody struct {
	SenderAddress tlb.MsgAddress
	Bid           tlb.Grams
	Username      tlb.FixedLengthText
	Content       tlb.Ref[tlb.Any]
	AuctionConfig tlb.Ref[TeleitemAuctionConfig]
	RoyaltyParams tlb.Ref[NftRoyaltyParams]
}

type GetStaticDataMsgBody struct {
	QueryId uint64
}

type TonstakePoolWithdrawMsgBody struct {
	QueryId         uint64
	JettonAmount    tlb.Grams
	FromAddress     tlb.MsgAddress
	ResponseAddress tlb.MsgAddress
}

type TeleitemCancelAuctionMsgBody struct {
	QueryId int64
}

type ProofStorageMsgBody struct {
	QueryId       uint64
	FileDictProof tlb.Ref[tlb.Any]
}

type TonstakeControllerSendRequestLoanMsgBody struct {
	QueryId    uint64
	MinLoan    tlb.Grams
	MaxLoan    tlb.Grams
	MaxInterst tlb.Uint18
}

type TelemintDeployMsgBody struct {
	Sig tlb.Bits512
	Msg TelemintUnsignedDeploy
}

type TelemintDeployV2MsgBody struct {
	Sig tlb.Bits512
	Msg TelemintUnsignedDeployV2
}

type StorageWithdrawMsgBody struct {
	QueryId uint64
}

type TonstakePoolDepositMsgBody struct {
	QueryId uint64
}

type TeleitemStartAuctionMsgBody struct {
	QueryId       int64
	AuctionConfig tlb.Ref[TeleitemAuctionConfig]
}

type UpdatePubkeyMsgBody struct {
	QueryId   uint64
	NewPubkey tlb.Bits256
}

type UpdateStorageParamsMsgBody struct {
	QueryId            uint64
	AcceptNewContracts bool
	RatePerMbDay       tlb.Grams
	MaxSpan            uint32
	MinimalFileSize    uint64
	MaximalFileSize    uint64
}

type ChannelCooperativeCloseMsgBody struct {
	SigA      tlb.Ref[tlb.Bits512]
	SigB      tlb.Ref[tlb.Bits512]
	Tag       uint32
	ChannelId tlb.Uint128
	BalanceA  tlb.Grams
	BalanceB  tlb.Grams
	SeqnoA    uint64
	SeqnoB    uint64
}

type JettonBurnMsgBody struct {
	QueryId             uint64
	Amount              tlb.VarUInteger16
	ResponseDestination tlb.MsgAddress
	CustomPayload       tlb.Maybe[tlb.Ref[tlb.Any]]
}

type NftTransferMsgBody struct {
	QueryId             uint64
	NewOwner            tlb.MsgAddress
	ResponseDestination tlb.MsgAddress
	CustomPayload       tlb.Maybe[tlb.Ref[tlb.Any]]
	ForwardAmount       tlb.VarUInteger16
	ForwardPayload      tlb.EitherRef[tlb.Any]
}

type WalletPluginDestructMsgBody struct{}

type SettleChannelConditionalsMsgBody struct {
	FromA                bool
	Signature            tlb.Bits512
	Tag                  uint32
	ChannelId            tlb.Uint128
	ConditionalsToSettle tlb.HashmapE[tlb.Uint32, tlb.Any]
}

type TopUpChannelBalanceMsgBody struct {
	AddA tlb.Grams
	AddB tlb.Grams
}

type GetRoyaltyParamsMsgBody struct {
	QueryId uint64
}

type SbtRevokeMsgBody struct {
	QueryId uint64
}

type PaymentRequestMsgBody struct {
	QueryId uint64
	Amount  tlb.CurrencyCollection
}

type TonstakeControllerPoolUnhaltMsgBody struct {
	QueryId uint64
}

type JettonNotifyMsgBody struct {
	QueryId        uint64
	Amount         tlb.VarUInteger16
	Sender         tlb.MsgAddress
	ForwardPayload tlb.EitherRef[tlb.Any]
}

type SubscriptionPaymentMsgBody struct{}

type ChannelCooperativeCommitMsgBody struct {
	SigA      tlb.Ref[tlb.Bits512]
	SigB      tlb.Ref[tlb.Bits512]
	Tag       uint32
	ChannelId tlb.Uint128
	SeqnoA    uint64
	SeqnoB    uint64
}

type TonstakeControllerPoolSetSudoerMsgBody struct {
	QueryId uint64
	Sudoer  tlb.MsgAddress
}

type CloseStorageContractMsgBody struct {
	QueryId uint64
}

type AcceptStorageContractMsgBody struct {
	QueryId uint64
}

type TonstakePoolSetRolesMsgBody struct {
	Governor        tlb.Maybe[tlb.MsgAddress]
	InterestManager tlb.Maybe[tlb.MsgAddress]
	Halter          tlb.Maybe[tlb.MsgAddress]
	Consigliere     tlb.Maybe[tlb.MsgAddress]
}

type TonstakeControllerApproveMsgBody struct {
	QueryId uint64
}

type WhalesNominatorsDepositMsgBody struct {
	QueryId int64
	Gas     tlb.Grams
}

type ReportStaticDataMsgBody struct {
	QueryId    uint64
	Index      tlb.Uint256
	Collection tlb.MsgAddress
}

type TonstakeControllerPoolUpgradeMsgBody struct {
	QueryId      uint64
	Data         tlb.Maybe[tlb.Ref[tlb.Any]]
	Code         tlb.Maybe[tlb.Ref[tlb.Any]]
	AfterUpgrade tlb.Maybe[tlb.Ref[tlb.Any]]
}

type ReportRoyaltyParamsMsgBody struct {
	QueryId     uint64
	Numerator   uint16
	Denominator uint16
	Destination tlb.MsgAddress
}

type StorageRewardWithdrawalMsgBody struct {
	QueryId uint64
}

type StorageContractTerminatedMsgBody struct {
	CurLt       uint64
	TorrentHash tlb.Bits256
}

type TonstakeControllerWithdrawValidatorMsgBody struct {
	QueryId uint64
}

type SbtRequestOwnerMsgBody struct {
	QueryId        uint64
	Dest           tlb.MsgAddress
	ForwardPayload tlb.Ref[tlb.Any]
	WithContent    bool
}

type TonstakeControllerTopUpMsgBody struct {
	QueryId uint64
}

type StorageContractConfirmedMsgBody struct {
	CurLt       uint64
	TorrentHash tlb.Bits256
}

type ExcessMsgBody struct {
	QueryId uint64
}

type WhalesNominatorsWithdrawMsgBody struct {
	QueryId int64
	Gas     tlb.Grams
	Amount  tlb.Grams
}

type ChannelClosedMsgBody struct {
	ChannelId tlb.Uint128
}

type TonstakePoolLoanRepaymentMsgBody struct {
	QueryId uint64
}

type TonstakeControllerNewStakeMsgBody struct {
	QueryId         uint64
	Value           tlb.Grams
	ValidatorPubkey tlb.Uint256
	StakeAt         uint32
	MaxFactor       uint32
	AdnlAddr        tlb.Uint256
	Signature       tlb.Ref[tlb.Bits512]
}

type WalletPluginDestructResponseMsgBody struct{}

type DeployStorageContractMsgBody struct {
	QueryId         uint64
	Info            tlb.Ref[TorrentInfo]
	MerkleHash      tlb.Bits256
	ExpectedRate    tlb.Grams
	ExpectedMaxSpan uint32
}

type TonstakeControllerDisapproveMsgBody struct {
	QueryId uint64
}

type TonstakeControllerRecoverStakeMsgBody struct {
	QueryId uint64
}

type TonstakeControllerReturnUnusedLoanMsgBody struct {
	QueryId uint64
}

type PaymentRequestResponseMsgBody struct{}

type TonstakeControllerUpdateValidatorHashMsgBody struct {
	QueryId uint64
}

// MessageDecoder takes in a message body as a cell and tries to decode it based on the first 4 bytes.
// On success, it returns an operation name and a decoded body.
func MessageDecoder(cell *boc.Cell) (MsgOpName, any, error) {
	tag, err := cell.ReadUint(32)
	if err != nil {
		return "", nil, err
	}
	switch tag {
	case 0x0:
		var res TextCommentMsgBody
		err = tlb.Unmarshal(cell, &res)
		return TextCommentMsgOp, res, err
	case 0x4ded148:
		var res ProveOwnershipMsgBody
		err = tlb.Unmarshal(cell, &res)
		return ProveOwnershipMsgOp, res, err
	case 0x5138d91:
		var res NftOwnershipAssignedMsgBody
		err = tlb.Unmarshal(cell, &res)
		return NftOwnershipAssignedMsgOp, res, err
	case 0x524c7ae:
		var res OwnershipProofMsgBody
		err = tlb.Unmarshal(cell, &res)
		return OwnershipProofMsgOp, res, err
	case 0x88eaa32:
		var res ChallengeQuarantinedChannelStateMsgBody
		err = tlb.Unmarshal(cell, &res)
		return ChallengeQuarantinedChannelStateMsgOp, res, err
	case 0xdd607e3:
		var res SbtOwnerInfoMsgBody
		err = tlb.Unmarshal(cell, &res)
		return SbtOwnerInfoMsgOp, res, err
	case 0xe0620c2:
		var res InitPaymentChannelMsgBody
		err = tlb.Unmarshal(cell, &res)
		return InitPaymentChannelMsgOp, res, err
	case 0xf8a7ea5:
		var res JettonTransferMsgBody
		err = tlb.Unmarshal(cell, &res)
		return JettonTransferMsgOp, res, err
	case 0x107c49ef:
		var res OfferStorageContractMsgBody
		err = tlb.Unmarshal(cell, &res)
		return OfferStorageContractMsgOp, res, err
	case 0x139a1b4e:
		var res TonstakeControllerPoolHaltMsgBody
		err = tlb.Unmarshal(cell, &res)
		return TonstakeControllerPoolHaltMsgOp, res, err
	case 0x1690c604:
		var res TonstakeControllerCreditMsgBody
		err = tlb.Unmarshal(cell, &res)
		return TonstakeControllerCreditMsgOp, res, err
	case 0x178d4519:
		var res JettonInternalTransferMsgBody
		err = tlb.Unmarshal(cell, &res)
		return JettonInternalTransferMsgOp, res, err
	case 0x1f04537a:
		var res SbtDestroyMsgBody
		err = tlb.Unmarshal(cell, &res)
		return SbtDestroyMsgOp, res, err
	case 0x1f151acf:
		var res StartUncooperativeChannelCloseMsgBody
		err = tlb.Unmarshal(cell, &res)
		return StartUncooperativeChannelCloseMsgOp, res, err
	case 0x25432a91:
		var res FinishUncooperativeChannelCloseMsgBody
		err = tlb.Unmarshal(cell, &res)
		return FinishUncooperativeChannelCloseMsgOp, res, err
	case 0x270695fb:
		var res TonstakeControllerPoolSendMessageMsgBody
		err = tlb.Unmarshal(cell, &res)
		return TonstakeControllerPoolSendMessageMsgOp, res, err
	case 0x299a3e15:
		var res TeleitemDeployMsgBody
		err = tlb.Unmarshal(cell, &res)
		return TeleitemDeployMsgOp, res, err
	case 0x2fcb26a2:
		var res GetStaticDataMsgBody
		err = tlb.Unmarshal(cell, &res)
		return GetStaticDataMsgOp, res, err
	case 0x319b0cdc:
		var res TonstakePoolWithdrawMsgBody
		err = tlb.Unmarshal(cell, &res)
		return TonstakePoolWithdrawMsgOp, res, err
	case 0x371638ae:
		var res TeleitemCancelAuctionMsgBody
		err = tlb.Unmarshal(cell, &res)
		return TeleitemCancelAuctionMsgOp, res, err
	case 0x419d5d4d:
		var res ProofStorageMsgBody
		err = tlb.Unmarshal(cell, &res)
		return ProofStorageMsgOp, res, err
	case 0x452f7112:
		var res TonstakeControllerSendRequestLoanMsgBody
		err = tlb.Unmarshal(cell, &res)
		return TonstakeControllerSendRequestLoanMsgOp, res, err
	case 0x4637289a:
		var res TelemintDeployMsgBody
		err = tlb.Unmarshal(cell, &res)
		return TelemintDeployMsgOp, res, err
	case 0x4637289b:
		var res TelemintDeployV2MsgBody
		err = tlb.Unmarshal(cell, &res)
		return TelemintDeployV2MsgOp, res, err
	case 0x46ed2e94:
		var res StorageWithdrawMsgBody
		err = tlb.Unmarshal(cell, &res)
		return StorageWithdrawMsgOp, res, err
	case 0x47d54391:
		var res TonstakePoolDepositMsgBody
		err = tlb.Unmarshal(cell, &res)
		return TonstakePoolDepositMsgOp, res, err
	case 0x487a8e81:
		var res TeleitemStartAuctionMsgBody
		err = tlb.Unmarshal(cell, &res)
		return TeleitemStartAuctionMsgOp, res, err
	case 0x53f34cd6:
		var res UpdatePubkeyMsgBody
		err = tlb.Unmarshal(cell, &res)
		return UpdatePubkeyMsgOp, res, err
	case 0x54cbf19b:
		var res UpdateStorageParamsMsgBody
		err = tlb.Unmarshal(cell, &res)
		return UpdateStorageParamsMsgOp, res, err
	case 0x5577587e:
		var res ChannelCooperativeCloseMsgBody
		err = tlb.Unmarshal(cell, &res)
		return ChannelCooperativeCloseMsgOp, res, err
	case 0x595f07bc:
		var res JettonBurnMsgBody
		err = tlb.Unmarshal(cell, &res)
		return JettonBurnMsgOp, res, err
	case 0x5fcc3d14:
		var res NftTransferMsgBody
		err = tlb.Unmarshal(cell, &res)
		return NftTransferMsgOp, res, err
	case 0x64737472:
		var res WalletPluginDestructMsgBody
		err = tlb.Unmarshal(cell, &res)
		return WalletPluginDestructMsgOp, res, err
	case 0x66f6f069:
		var res SettleChannelConditionalsMsgBody
		err = tlb.Unmarshal(cell, &res)
		return SettleChannelConditionalsMsgOp, res, err
	case 0x67c7d281:
		var res TopUpChannelBalanceMsgBody
		err = tlb.Unmarshal(cell, &res)
		return TopUpChannelBalanceMsgOp, res, err
	case 0x693d3950:
		var res GetRoyaltyParamsMsgBody
		err = tlb.Unmarshal(cell, &res)
		return GetRoyaltyParamsMsgOp, res, err
	case 0x6f89f5e3:
		var res SbtRevokeMsgBody
		err = tlb.Unmarshal(cell, &res)
		return SbtRevokeMsgOp, res, err
	case 0x706c7567:
		var res PaymentRequestMsgBody
		err = tlb.Unmarshal(cell, &res)
		return PaymentRequestMsgOp, res, err
	case 0x7247e7a5:
		var res TonstakeControllerPoolUnhaltMsgBody
		err = tlb.Unmarshal(cell, &res)
		return TonstakeControllerPoolUnhaltMsgOp, res, err
	case 0x7362d09c:
		var res JettonNotifyMsgBody
		err = tlb.Unmarshal(cell, &res)
		return JettonNotifyMsgOp, res, err
	case 0x73756273:
		var res SubscriptionPaymentMsgBody
		err = tlb.Unmarshal(cell, &res)
		return SubscriptionPaymentMsgOp, res, err
	case 0x79a126ef:
		var res ChannelCooperativeCommitMsgBody
		err = tlb.Unmarshal(cell, &res)
		return ChannelCooperativeCommitMsgOp, res, err
	case 0x79e7c016:
		var res TonstakeControllerPoolSetSudoerMsgBody
		err = tlb.Unmarshal(cell, &res)
		return TonstakeControllerPoolSetSudoerMsgOp, res, err
	case 0x79f937ea:
		var res CloseStorageContractMsgBody
		err = tlb.Unmarshal(cell, &res)
		return CloseStorageContractMsgOp, res, err
	case 0x7a361688:
		var res AcceptStorageContractMsgBody
		err = tlb.Unmarshal(cell, &res)
		return AcceptStorageContractMsgOp, res, err
	case 0x7a756db8:
		var res TonstakePoolSetRolesMsgBody
		err = tlb.Unmarshal(cell, &res)
		return TonstakePoolSetRolesMsgOp, res, err
	case 0x7b4b42e6:
		var res TonstakeControllerApproveMsgBody
		err = tlb.Unmarshal(cell, &res)
		return TonstakeControllerApproveMsgOp, res, err
	case 0x7bcd1fef:
		var res WhalesNominatorsDepositMsgBody
		err = tlb.Unmarshal(cell, &res)
		return WhalesNominatorsDepositMsgOp, res, err
	case 0x8b771735:
		var res ReportStaticDataMsgBody
		err = tlb.Unmarshal(cell, &res)
		return ReportStaticDataMsgOp, res, err
	case 0x96e7f528:
		var res TonstakeControllerPoolUpgradeMsgBody
		err = tlb.Unmarshal(cell, &res)
		return TonstakeControllerPoolUpgradeMsgOp, res, err
	case 0xa8cb00ad:
		var res ReportRoyaltyParamsMsgBody
		err = tlb.Unmarshal(cell, &res)
		return ReportRoyaltyParamsMsgOp, res, err
	case 0xa91baf56:
		var res StorageRewardWithdrawalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return StorageRewardWithdrawalMsgOp, res, err
	case 0xb6236d63:
		var res StorageContractTerminatedMsgBody
		err = tlb.Unmarshal(cell, &res)
		return StorageContractTerminatedMsgOp, res, err
	case 0xcefaaefd:
		var res TonstakeControllerWithdrawValidatorMsgBody
		err = tlb.Unmarshal(cell, &res)
		return TonstakeControllerWithdrawValidatorMsgOp, res, err
	case 0xd0c3bfea:
		var res SbtRequestOwnerMsgBody
		err = tlb.Unmarshal(cell, &res)
		return SbtRequestOwnerMsgOp, res, err
	case 0xd372158c:
		var res TonstakeControllerTopUpMsgBody
		err = tlb.Unmarshal(cell, &res)
		return TonstakeControllerTopUpMsgOp, res, err
	case 0xd4caedcd:
		var res StorageContractConfirmedMsgBody
		err = tlb.Unmarshal(cell, &res)
		return StorageContractConfirmedMsgOp, res, err
	case 0xd53276db:
		var res ExcessMsgBody
		err = tlb.Unmarshal(cell, &res)
		return ExcessMsgOp, res, err
	case 0xda803efd:
		var res WhalesNominatorsWithdrawMsgBody
		err = tlb.Unmarshal(cell, &res)
		return WhalesNominatorsWithdrawMsgOp, res, err
	case 0xdddc88ba:
		var res ChannelClosedMsgBody
		err = tlb.Unmarshal(cell, &res)
		return ChannelClosedMsgOp, res, err
	case 0xdfdca27b:
		var res TonstakePoolLoanRepaymentMsgBody
		err = tlb.Unmarshal(cell, &res)
		return TonstakePoolLoanRepaymentMsgOp, res, err
	case 0xe0505d0e:
		var res TonstakeControllerNewStakeMsgBody
		err = tlb.Unmarshal(cell, &res)
		return TonstakeControllerNewStakeMsgOp, res, err
	case 0xe4737472:
		var res WalletPluginDestructResponseMsgBody
		err = tlb.Unmarshal(cell, &res)
		return WalletPluginDestructResponseMsgOp, res, err
	case 0xe4748df1:
		var res DeployStorageContractMsgBody
		err = tlb.Unmarshal(cell, &res)
		return DeployStorageContractMsgOp, res, err
	case 0xe8a0abfe:
		var res TonstakeControllerDisapproveMsgBody
		err = tlb.Unmarshal(cell, &res)
		return TonstakeControllerDisapproveMsgOp, res, err
	case 0xeb373a05:
		var res TonstakeControllerRecoverStakeMsgBody
		err = tlb.Unmarshal(cell, &res)
		return TonstakeControllerRecoverStakeMsgOp, res, err
	case 0xed7378a6:
		var res TonstakeControllerReturnUnusedLoanMsgBody
		err = tlb.Unmarshal(cell, &res)
		return TonstakeControllerReturnUnusedLoanMsgOp, res, err
	case 0xf06c7567:
		var res PaymentRequestResponseMsgBody
		err = tlb.Unmarshal(cell, &res)
		return PaymentRequestResponseMsgOp, res, err
	case 0xf0fd2250:
		var res TonstakeControllerUpdateValidatorHashMsgBody
		err = tlb.Unmarshal(cell, &res)
		return TonstakeControllerUpdateValidatorHashMsgOp, res, err
	}
	return "", nil, fmt.Errorf("invalid message tag")
}

// MsgOpName is a human-friendly name for a message's operation which is identified by the first 4 bytes of the message's body.
type MsgOpName = string

const (
	TextCommentMsgOp                           MsgOpName = "TextComment"
	ProveOwnershipMsgOp                        MsgOpName = "ProveOwnership"
	NftOwnershipAssignedMsgOp                  MsgOpName = "NftOwnershipAssigned"
	OwnershipProofMsgOp                        MsgOpName = "OwnershipProof"
	ChallengeQuarantinedChannelStateMsgOp      MsgOpName = "ChallengeQuarantinedChannelState"
	SbtOwnerInfoMsgOp                          MsgOpName = "SbtOwnerInfo"
	InitPaymentChannelMsgOp                    MsgOpName = "InitPaymentChannel"
	JettonTransferMsgOp                        MsgOpName = "JettonTransfer"
	OfferStorageContractMsgOp                  MsgOpName = "OfferStorageContract"
	TonstakeControllerPoolHaltMsgOp            MsgOpName = "TonstakeControllerPoolHalt"
	TonstakeControllerCreditMsgOp              MsgOpName = "TonstakeControllerCredit"
	JettonInternalTransferMsgOp                MsgOpName = "JettonInternalTransfer"
	SbtDestroyMsgOp                            MsgOpName = "SbtDestroy"
	StartUncooperativeChannelCloseMsgOp        MsgOpName = "StartUncooperativeChannelClose"
	FinishUncooperativeChannelCloseMsgOp       MsgOpName = "FinishUncooperativeChannelClose"
	TonstakeControllerPoolSendMessageMsgOp     MsgOpName = "TonstakeControllerPoolSendMessage"
	TeleitemDeployMsgOp                        MsgOpName = "TeleitemDeploy"
	GetStaticDataMsgOp                         MsgOpName = "GetStaticData"
	TonstakePoolWithdrawMsgOp                  MsgOpName = "TonstakePoolWithdraw"
	TeleitemCancelAuctionMsgOp                 MsgOpName = "TeleitemCancelAuction"
	ProofStorageMsgOp                          MsgOpName = "ProofStorage"
	TonstakeControllerSendRequestLoanMsgOp     MsgOpName = "TonstakeControllerSendRequestLoan"
	TelemintDeployMsgOp                        MsgOpName = "TelemintDeploy"
	TelemintDeployV2MsgOp                      MsgOpName = "TelemintDeployV2"
	StorageWithdrawMsgOp                       MsgOpName = "StorageWithdraw"
	TonstakePoolDepositMsgOp                   MsgOpName = "TonstakePoolDeposit"
	TeleitemStartAuctionMsgOp                  MsgOpName = "TeleitemStartAuction"
	UpdatePubkeyMsgOp                          MsgOpName = "UpdatePubkey"
	UpdateStorageParamsMsgOp                   MsgOpName = "UpdateStorageParams"
	ChannelCooperativeCloseMsgOp               MsgOpName = "ChannelCooperativeClose"
	JettonBurnMsgOp                            MsgOpName = "JettonBurn"
	NftTransferMsgOp                           MsgOpName = "NftTransfer"
	WalletPluginDestructMsgOp                  MsgOpName = "WalletPluginDestruct"
	SettleChannelConditionalsMsgOp             MsgOpName = "SettleChannelConditionals"
	TopUpChannelBalanceMsgOp                   MsgOpName = "TopUpChannelBalance"
	GetRoyaltyParamsMsgOp                      MsgOpName = "GetRoyaltyParams"
	SbtRevokeMsgOp                             MsgOpName = "SbtRevoke"
	PaymentRequestMsgOp                        MsgOpName = "PaymentRequest"
	TonstakeControllerPoolUnhaltMsgOp          MsgOpName = "TonstakeControllerPoolUnhalt"
	JettonNotifyMsgOp                          MsgOpName = "JettonNotify"
	SubscriptionPaymentMsgOp                   MsgOpName = "SubscriptionPayment"
	ChannelCooperativeCommitMsgOp              MsgOpName = "ChannelCooperativeCommit"
	TonstakeControllerPoolSetSudoerMsgOp       MsgOpName = "TonstakeControllerPoolSetSudoer"
	CloseStorageContractMsgOp                  MsgOpName = "CloseStorageContract"
	AcceptStorageContractMsgOp                 MsgOpName = "AcceptStorageContract"
	TonstakePoolSetRolesMsgOp                  MsgOpName = "TonstakePoolSetRoles"
	TonstakeControllerApproveMsgOp             MsgOpName = "TonstakeControllerApprove"
	WhalesNominatorsDepositMsgOp               MsgOpName = "WhalesNominatorsDeposit"
	ReportStaticDataMsgOp                      MsgOpName = "ReportStaticData"
	TonstakeControllerPoolUpgradeMsgOp         MsgOpName = "TonstakeControllerPoolUpgrade"
	ReportRoyaltyParamsMsgOp                   MsgOpName = "ReportRoyaltyParams"
	StorageRewardWithdrawalMsgOp               MsgOpName = "StorageRewardWithdrawal"
	StorageContractTerminatedMsgOp             MsgOpName = "StorageContractTerminated"
	TonstakeControllerWithdrawValidatorMsgOp   MsgOpName = "TonstakeControllerWithdrawValidator"
	SbtRequestOwnerMsgOp                       MsgOpName = "SbtRequestOwner"
	TonstakeControllerTopUpMsgOp               MsgOpName = "TonstakeControllerTopUp"
	StorageContractConfirmedMsgOp              MsgOpName = "StorageContractConfirmed"
	ExcessMsgOp                                MsgOpName = "Excess"
	WhalesNominatorsWithdrawMsgOp              MsgOpName = "WhalesNominatorsWithdraw"
	ChannelClosedMsgOp                         MsgOpName = "ChannelClosed"
	TonstakePoolLoanRepaymentMsgOp             MsgOpName = "TonstakePoolLoanRepayment"
	TonstakeControllerNewStakeMsgOp            MsgOpName = "TonstakeControllerNewStake"
	WalletPluginDestructResponseMsgOp          MsgOpName = "WalletPluginDestructResponse"
	DeployStorageContractMsgOp                 MsgOpName = "DeployStorageContract"
	TonstakeControllerDisapproveMsgOp          MsgOpName = "TonstakeControllerDisapprove"
	TonstakeControllerRecoverStakeMsgOp        MsgOpName = "TonstakeControllerRecoverStake"
	TonstakeControllerReturnUnusedLoanMsgOp    MsgOpName = "TonstakeControllerReturnUnusedLoan"
	PaymentRequestResponseMsgOp                MsgOpName = "PaymentRequestResponse"
	TonstakeControllerUpdateValidatorHashMsgOp MsgOpName = "TonstakeControllerUpdateValidatorHash"
)

var KnownMsgTypes = map[string]any{
	TextCommentMsgOp:                           TextCommentMsgBody{},
	ProveOwnershipMsgOp:                        ProveOwnershipMsgBody{},
	NftOwnershipAssignedMsgOp:                  NftOwnershipAssignedMsgBody{},
	OwnershipProofMsgOp:                        OwnershipProofMsgBody{},
	ChallengeQuarantinedChannelStateMsgOp:      ChallengeQuarantinedChannelStateMsgBody{},
	SbtOwnerInfoMsgOp:                          SbtOwnerInfoMsgBody{},
	InitPaymentChannelMsgOp:                    InitPaymentChannelMsgBody{},
	JettonTransferMsgOp:                        JettonTransferMsgBody{},
	OfferStorageContractMsgOp:                  OfferStorageContractMsgBody{},
	TonstakeControllerPoolHaltMsgOp:            TonstakeControllerPoolHaltMsgBody{},
	TonstakeControllerCreditMsgOp:              TonstakeControllerCreditMsgBody{},
	JettonInternalTransferMsgOp:                JettonInternalTransferMsgBody{},
	SbtDestroyMsgOp:                            SbtDestroyMsgBody{},
	StartUncooperativeChannelCloseMsgOp:        StartUncooperativeChannelCloseMsgBody{},
	FinishUncooperativeChannelCloseMsgOp:       FinishUncooperativeChannelCloseMsgBody{},
	TonstakeControllerPoolSendMessageMsgOp:     TonstakeControllerPoolSendMessageMsgBody{},
	TeleitemDeployMsgOp:                        TeleitemDeployMsgBody{},
	GetStaticDataMsgOp:                         GetStaticDataMsgBody{},
	TonstakePoolWithdrawMsgOp:                  TonstakePoolWithdrawMsgBody{},
	TeleitemCancelAuctionMsgOp:                 TeleitemCancelAuctionMsgBody{},
	ProofStorageMsgOp:                          ProofStorageMsgBody{},
	TonstakeControllerSendRequestLoanMsgOp:     TonstakeControllerSendRequestLoanMsgBody{},
	TelemintDeployMsgOp:                        TelemintDeployMsgBody{},
	TelemintDeployV2MsgOp:                      TelemintDeployV2MsgBody{},
	StorageWithdrawMsgOp:                       StorageWithdrawMsgBody{},
	TonstakePoolDepositMsgOp:                   TonstakePoolDepositMsgBody{},
	TeleitemStartAuctionMsgOp:                  TeleitemStartAuctionMsgBody{},
	UpdatePubkeyMsgOp:                          UpdatePubkeyMsgBody{},
	UpdateStorageParamsMsgOp:                   UpdateStorageParamsMsgBody{},
	ChannelCooperativeCloseMsgOp:               ChannelCooperativeCloseMsgBody{},
	JettonBurnMsgOp:                            JettonBurnMsgBody{},
	NftTransferMsgOp:                           NftTransferMsgBody{},
	WalletPluginDestructMsgOp:                  WalletPluginDestructMsgBody{},
	SettleChannelConditionalsMsgOp:             SettleChannelConditionalsMsgBody{},
	TopUpChannelBalanceMsgOp:                   TopUpChannelBalanceMsgBody{},
	GetRoyaltyParamsMsgOp:                      GetRoyaltyParamsMsgBody{},
	SbtRevokeMsgOp:                             SbtRevokeMsgBody{},
	PaymentRequestMsgOp:                        PaymentRequestMsgBody{},
	TonstakeControllerPoolUnhaltMsgOp:          TonstakeControllerPoolUnhaltMsgBody{},
	JettonNotifyMsgOp:                          JettonNotifyMsgBody{},
	SubscriptionPaymentMsgOp:                   SubscriptionPaymentMsgBody{},
	ChannelCooperativeCommitMsgOp:              ChannelCooperativeCommitMsgBody{},
	TonstakeControllerPoolSetSudoerMsgOp:       TonstakeControllerPoolSetSudoerMsgBody{},
	CloseStorageContractMsgOp:                  CloseStorageContractMsgBody{},
	AcceptStorageContractMsgOp:                 AcceptStorageContractMsgBody{},
	TonstakePoolSetRolesMsgOp:                  TonstakePoolSetRolesMsgBody{},
	TonstakeControllerApproveMsgOp:             TonstakeControllerApproveMsgBody{},
	WhalesNominatorsDepositMsgOp:               WhalesNominatorsDepositMsgBody{},
	ReportStaticDataMsgOp:                      ReportStaticDataMsgBody{},
	TonstakeControllerPoolUpgradeMsgOp:         TonstakeControllerPoolUpgradeMsgBody{},
	ReportRoyaltyParamsMsgOp:                   ReportRoyaltyParamsMsgBody{},
	StorageRewardWithdrawalMsgOp:               StorageRewardWithdrawalMsgBody{},
	StorageContractTerminatedMsgOp:             StorageContractTerminatedMsgBody{},
	TonstakeControllerWithdrawValidatorMsgOp:   TonstakeControllerWithdrawValidatorMsgBody{},
	SbtRequestOwnerMsgOp:                       SbtRequestOwnerMsgBody{},
	TonstakeControllerTopUpMsgOp:               TonstakeControllerTopUpMsgBody{},
	StorageContractConfirmedMsgOp:              StorageContractConfirmedMsgBody{},
	ExcessMsgOp:                                ExcessMsgBody{},
	WhalesNominatorsWithdrawMsgOp:              WhalesNominatorsWithdrawMsgBody{},
	ChannelClosedMsgOp:                         ChannelClosedMsgBody{},
	TonstakePoolLoanRepaymentMsgOp:             TonstakePoolLoanRepaymentMsgBody{},
	TonstakeControllerNewStakeMsgOp:            TonstakeControllerNewStakeMsgBody{},
	WalletPluginDestructResponseMsgOp:          WalletPluginDestructResponseMsgBody{},
	DeployStorageContractMsgOp:                 DeployStorageContractMsgBody{},
	TonstakeControllerDisapproveMsgOp:          TonstakeControllerDisapproveMsgBody{},
	TonstakeControllerRecoverStakeMsgOp:        TonstakeControllerRecoverStakeMsgBody{},
	TonstakeControllerReturnUnusedLoanMsgOp:    TonstakeControllerReturnUnusedLoanMsgBody{},
	PaymentRequestResponseMsgOp:                PaymentRequestResponseMsgBody{},
	TonstakeControllerUpdateValidatorHashMsgOp: TonstakeControllerUpdateValidatorHashMsgBody{},
}

var KnownGetMethodsDecoder = map[string][]func(tlb.VmStack) (string, any, error){
	"seqno":                               {DecodeSeqnoResult},
	"get_public_key":                      {DecodeGetPublicKeyResult},
	"get_subwallet_id":                    {DecodeGetSubwalletIdResult},
	"get_plugin_list":                     {DecodeGetPluginListResult},
	"is_plugin_installed":                 {DecodeIsPluginInstalledResult},
	"get_nft_data":                        {DecodeGetNftDataResult},
	"get_nft_content":                     {DecodeGetNftContentResult},
	"get_collection_data":                 {DecodeGetCollectionDataResult},
	"get_nft_address_by_index":            {DecodeGetNftAddressByIndexResult},
	"royalty_params":                      {DecodeRoyaltyParamsResult},
	"get_editor":                          {DecodeGetEditorResult},
	"get_auction_info":                    {DecodeGetAuctionInfoResult},
	"get_subscription_data":               {DecodeGetSubscriptionDataResult},
	"get_jetton_data":                     {DecodeGetJettonDataResult},
	"get_wallet_address":                  {DecodeGetWalletAddressResult},
	"get_wallet_data":                     {DecodeGetWalletDataResult},
	"dnsresolve":                          {DecodeDnsresolve_RecordsResult},
	"get_last_fill_up_time":               {DecodeGetLastFillUpTimeResult},
	"get_domain":                          {DecodeGetDomainResult},
	"get_full_domain":                     {DecodeGetFullDomainResult},
	"get_sale_data":                       {DecodeGetSaleData_BasicResult, DecodeGetSaleData_GetgemsResult, DecodeGetSaleData_GetgemsAuctionResult},
	"get_authority_address":               {DecodeGetAuthorityAddressResult},
	"get_revoked_time":                    {DecodeGetRevokedTimeResult},
	"get_channel_state":                   {DecodeGetChannelStateResult},
	"get_wallet_params":                   {DecodeGetWalletParamsResult},
	"get_storage_params":                  {DecodeGetStorageParamsResult},
	"get_storage_contract_address":        {DecodeGetStorageContractAddressResult},
	"get_storage_contract_data":           {DecodeGetStorageContractDataResult},
	"get_torrent_hash":                    {DecodeGetTorrentHashResult},
	"is_active":                           {DecodeIsActiveResult},
	"get_next_proof_info":                 {DecodeGetNextProofInfoResult},
	"list_nominators":                     {DecodeListNominatorsResult},
	"list_votes":                          {DecodeListVotesResult},
	"get_pool_data":                       {DecodeGetPoolData_TfResult},
	"get_staking_status":                  {DecodeGetStakingStatusResult},
	"get_pool_status":                     {DecodeGetPoolStatusResult},
	"get_member":                          {DecodeGetMember_WhalesNominatorResult},
	"get_members_raw":                     {DecodeGetMembersRaw_WhalesNominatorResult},
	"get_params":                          {DecodeGetParams_WhalesNominatorResult},
	"get_telemint_auction_state":          {DecodeGetTelemintAuctionStateResult},
	"get_telemint_auction_config":         {DecodeGetTelemintAuctionConfigResult},
	"get_telemint_token_name":             {DecodeGetTelemintTokenNameResult},
	"get_finance_data":                    {DecodeGetFinanceData_PoolResult},
	"get_current_round_deposit_minter":    {DecodeGetCurrentRoundDepositMinterResult},
	"get_current_round_withdrawal_minter": {DecodeGetCurrentRoundWithdrawalMinterResult},
	"get_validator_controller_data":       {DecodeGetValidatorControllerDataResult},
}

var KnownSimpleGetMethods = map[int][]func(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error){
	66763:  {GetFullDomain},
	67226:  {GetCurrentRoundWithdrawalMinter},
	69506:  {GetTelemintTokenName},
	71463:  {GetTorrentHash},
	72748:  {GetSaleData},
	78748:  {GetPublicKey},
	80697:  {GetAuctionInfo},
	81467:  {GetSubwalletId},
	81490:  {GetNextProofInfo},
	81689:  {GetPoolData},
	84760:  {GetAuthorityAddress},
	85143:  {Seqno},
	85719:  {RoyaltyParams},
	86593:  {GetStorageContractData},
	89295:  {GetMembersRaw},
	90228:  {GetEditor},
	91481:  {GetLastFillUpTime},
	92260:  {GetSubscriptionData},
	97026:  {GetWalletData},
	97667:  {GetRevokedTime},
	102351: {GetNftData},
	102491: {GetCollectionData},
	103232: {GetValidatorControllerData},
	104346: {GetStorageParams},
	106029: {GetJettonData},
	106901: {GetChannelState},
	107653: {GetPluginList},
	111161: {ListNominators},
	115150: {GetParams},
	116342: {GetCurrentRoundDepositMinter},
	119378: {GetDomain},
	120146: {GetPoolStatus},
	122058: {IsActive},
	122498: {GetTelemintAuctionState},
	123928: {GetStakingStatus},
	129619: {GetTelemintAuctionConfig},
	130271: {GetWalletParams},
	130309: {ListVotes},
	130614: {GetFinanceData},
}

var ResultTypes = []interface{}{
	&Dnsresolve_RecordsResult{},
	&GetAuctionInfoResult{},
	&GetAuthorityAddressResult{},
	&GetChannelStateResult{},
	&GetCollectionDataResult{},
	&GetCurrentRoundDepositMinterResult{},
	&GetCurrentRoundWithdrawalMinterResult{},
	&GetDomainResult{},
	&GetEditorResult{},
	&GetFinanceData_PoolResult{},
	&GetFullDomainResult{},
	&GetJettonDataResult{},
	&GetLastFillUpTimeResult{},
	&GetMember_WhalesNominatorResult{},
	&GetMembersRaw_WhalesNominatorResult{},
	&GetNextProofInfoResult{},
	&GetNftAddressByIndexResult{},
	&GetNftContentResult{},
	&GetNftDataResult{},
	&GetParams_WhalesNominatorResult{},
	&GetPluginListResult{},
	&GetPoolData_TfResult{},
	&GetPoolStatusResult{},
	&GetPublicKeyResult{},
	&GetRevokedTimeResult{},
	&GetSaleData_BasicResult{},
	&GetSaleData_GetgemsAuctionResult{},
	&GetSaleData_GetgemsResult{},
	&GetStakingStatusResult{},
	&GetStorageContractAddressResult{},
	&GetStorageContractDataResult{},
	&GetStorageParamsResult{},
	&GetSubscriptionDataResult{},
	&GetSubwalletIdResult{},
	&GetTelemintAuctionConfigResult{},
	&GetTelemintAuctionStateResult{},
	&GetTelemintTokenNameResult{},
	&GetTorrentHashResult{},
	&GetValidatorControllerDataResult{},
	&GetWalletAddressResult{},
	&GetWalletDataResult{},
	&GetWalletParamsResult{},
	&IsActiveResult{},
	&IsPluginInstalledResult{},
	&ListNominatorsResult{},
	&ListVotesResult{},
	&RoyaltyParamsResult{},
	&SeqnoResult{},
}

type Executor interface {
	RunSmcMethodByID(ctx context.Context, accountID tongo.AccountID, methodID int, params tlb.VmStack) (uint32, tlb.VmStack, error)
}

type SeqnoResult struct {
	State uint32
}

func Seqno(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 85143 for "seqno" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 85143, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeSeqnoResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeSeqnoResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result SeqnoResult
	err = stack.Unmarshal(&result)
	return "SeqnoResult", result, err
}

type GetPublicKeyResult struct {
	PublicKey tlb.Int257
}

func GetPublicKey(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 78748 for "get_public_key" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 78748, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetPublicKeyResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetPublicKeyResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetPublicKeyResult
	err = stack.Unmarshal(&result)
	return "GetPublicKeyResult", result, err
}

type GetSubwalletIdResult struct {
	SubwalletId uint32
}

func GetSubwalletId(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 81467 for "get_subwallet_id" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 81467, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetSubwalletIdResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetSubwalletIdResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetSubwalletIdResult
	err = stack.Unmarshal(&result)
	return "GetSubwalletIdResult", result, err
}

type GetPluginListResult struct {
	Plugins []struct {
		Workchain int32
		Address   tlb.Bits256
	}
}

func GetPluginList(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 107653 for "get_plugin_list" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 107653, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetPluginListResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetPluginListResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTuple" && stack[0].SumType != "VmStkNull") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetPluginListResult
	err = stack.Unmarshal(&result)
	return "GetPluginListResult", result, err
}

type IsPluginInstalledResult struct {
	Success bool
}

func IsPluginInstalled(ctx context.Context, executor Executor, reqAccountID tongo.AccountID, workchain int32, addrHash tlb.Int257) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val = tlb.VmStackValue{SumType: "VmStkTinyInt", VmStkTinyInt: int64(workchain)}
	stack.Put(val)
	val = tlb.VmStackValue{SumType: "VmStkInt", VmStkInt: addrHash}
	stack.Put(val)

	// MethodID = 76407 for "is_plugin_installed" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 76407, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeIsPluginInstalledResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeIsPluginInstalledResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result IsPluginInstalledResult
	err = stack.Unmarshal(&result)
	return "IsPluginInstalledResult", result, err
}

type GetNftDataResult struct {
	Init              bool
	Index             tlb.Int257
	CollectionAddress tlb.MsgAddress
	OwnerAddress      tlb.MsgAddress
	IndividualContent tlb.Any
}

func GetNftData(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 102351 for "get_nft_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 102351, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetNftDataResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetNftDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 5 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkSlice") || (stack[3].SumType != "VmStkSlice") || (stack[4].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetNftDataResult
	err = stack.Unmarshal(&result)
	return "GetNftDataResult", result, err
}

type GetNftContentResult struct {
	Content tlb.FullContent
}

func GetNftContent(ctx context.Context, executor Executor, reqAccountID tongo.AccountID, index tlb.Int257, individualContent tlb.Any) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val = tlb.VmStackValue{SumType: "VmStkInt", VmStkInt: index}
	stack.Put(val)
	val, err = tlb.TlbStructToVmCell(individualContent)
	if err != nil {
		return "", nil, err
	}
	stack.Put(val)

	// MethodID = 68445 for "get_nft_content" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 68445, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetNftContentResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetNftContentResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetNftContentResult
	err = stack.Unmarshal(&result)
	return "GetNftContentResult", result, err
}

type GetCollectionDataResult struct {
	NextItemIndex     tlb.Int257
	CollectionContent tlb.Any
	OwnerAddress      tlb.MsgAddress
}

func GetCollectionData(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 102491 for "get_collection_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 102491, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetCollectionDataResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetCollectionDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 3 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkCell") || (stack[2].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetCollectionDataResult
	err = stack.Unmarshal(&result)
	return "GetCollectionDataResult", result, err
}

type GetNftAddressByIndexResult struct {
	Address tlb.MsgAddress
}

func GetNftAddressByIndex(ctx context.Context, executor Executor, reqAccountID tongo.AccountID, index tlb.Int257) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val = tlb.VmStackValue{SumType: "VmStkInt", VmStkInt: index}
	stack.Put(val)

	// MethodID = 92067 for "get_nft_address_by_index" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 92067, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetNftAddressByIndexResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetNftAddressByIndexResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetNftAddressByIndexResult
	err = stack.Unmarshal(&result)
	return "GetNftAddressByIndexResult", result, err
}

type RoyaltyParamsResult struct {
	Numerator   uint16
	Denominator uint16
	Destination tlb.MsgAddress
}

func RoyaltyParams(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 85719 for "royalty_params" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 85719, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeRoyaltyParamsResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeRoyaltyParamsResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 3 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result RoyaltyParamsResult
	err = stack.Unmarshal(&result)
	return "RoyaltyParamsResult", result, err
}

type GetEditorResult struct {
	Editor tlb.MsgAddress
}

func GetEditor(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 90228 for "get_editor" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 90228, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetEditorResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetEditorResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetEditorResult
	err = stack.Unmarshal(&result)
	return "GetEditorResult", result, err
}

type GetAuctionInfoResult struct {
	MaxBidAddress  tlb.MsgAddress
	MaxBidAmount   uint64
	AuctionEndTime uint64
}

func GetAuctionInfo(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 80697 for "get_auction_info" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 80697, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetAuctionInfoResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetAuctionInfoResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 3 || (stack[0].SumType != "VmStkSlice") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetAuctionInfoResult
	err = stack.Unmarshal(&result)
	return "GetAuctionInfoResult", result, err
}

type GetSubscriptionDataResult struct {
	Wallet struct {
		Workchain uint32
		Address   tlb.Bits256
	}

	Beneficiary struct {
		Workchain uint32
		Address   tlb.Bits256
	}

	Amount          uint64
	Period          uint64
	StartTime       uint64
	Timeout         uint64
	LastPaymentTime uint64
	LastRequestTime uint64
	FailedAttempts  uint32
	SubscriptionId  uint64
}

func GetSubscriptionData(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 92260 for "get_subscription_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 92260, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetSubscriptionDataResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetSubscriptionDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 10 || (stack[0].SumType != "VmStkTuple") || (stack[1].SumType != "VmStkTuple") || (stack[2].SumType != "VmStkTinyInt") || (stack[3].SumType != "VmStkTinyInt") || (stack[4].SumType != "VmStkTinyInt") || (stack[5].SumType != "VmStkTinyInt") || (stack[6].SumType != "VmStkTinyInt") || (stack[7].SumType != "VmStkTinyInt") || (stack[8].SumType != "VmStkTinyInt") || (stack[9].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetSubscriptionDataResult
	err = stack.Unmarshal(&result)
	return "GetSubscriptionDataResult", result, err
}

type GetJettonDataResult struct {
	TotalSupply      tlb.Int257
	Mintable         int8
	AdminAddress     tlb.MsgAddress
	JettonContent    tlb.Any
	JettonWalletCode tlb.Any
}

func GetJettonData(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 106029 for "get_jetton_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 106029, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetJettonDataResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetJettonDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 5 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkSlice") || (stack[3].SumType != "VmStkCell") || (stack[4].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetJettonDataResult
	err = stack.Unmarshal(&result)
	return "GetJettonDataResult", result, err
}

type GetWalletAddressResult struct {
	JettonWalletAddress tlb.MsgAddress
}

func GetWalletAddress(ctx context.Context, executor Executor, reqAccountID tongo.AccountID, ownerAddress tlb.MsgAddress) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val, err = tlb.TlbStructToVmCellSlice(ownerAddress)
	if err != nil {
		return "", nil, err
	}
	stack.Put(val)

	// MethodID = 103289 for "get_wallet_address" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 103289, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetWalletAddressResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetWalletAddressResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetWalletAddressResult
	err = stack.Unmarshal(&result)
	return "GetWalletAddressResult", result, err
}

type GetWalletDataResult struct {
	Balance          tlb.Int257
	Owner            tlb.MsgAddress
	Jetton           tlb.MsgAddress
	JettonWalletCode tlb.Any
}

func GetWalletData(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 97026 for "get_wallet_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 97026, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetWalletDataResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetWalletDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 4 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkSlice") || (stack[2].SumType != "VmStkSlice") || (stack[3].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetWalletDataResult
	err = stack.Unmarshal(&result)
	return "GetWalletDataResult", result, err
}

type Dnsresolve_RecordsResult struct {
	ResolvedBits int64
	Result       tlb.DNSRecordSet
}

func Dnsresolve(ctx context.Context, executor Executor, reqAccountID tongo.AccountID, domain []byte, category tlb.Int257) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val, err = tlb.TlbStructToVmCellSlice(domain)
	if err != nil {
		return "", nil, err
	}
	stack.Put(val)
	val = tlb.VmStackValue{SumType: "VmStkInt", VmStkInt: category}
	stack.Put(val)

	// MethodID = 123660 for "dnsresolve" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 123660, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeDnsresolve_RecordsResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeDnsresolve_RecordsResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 2 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result Dnsresolve_RecordsResult
	err = stack.Unmarshal(&result)
	return "Dnsresolve_RecordsResult", result, err
}

type GetLastFillUpTimeResult struct {
	LastFillUpTime uint64
}

func GetLastFillUpTime(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 91481 for "get_last_fill_up_time" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 91481, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetLastFillUpTimeResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetLastFillUpTimeResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetLastFillUpTimeResult
	err = stack.Unmarshal(&result)
	return "GetLastFillUpTimeResult", result, err
}

type GetDomainResult struct {
	Domain string
}

func GetDomain(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 119378 for "get_domain" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 119378, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetDomainResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetDomainResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetDomainResult
	err = stack.Unmarshal(&result)
	return "GetDomainResult", result, err
}

type GetFullDomainResult struct {
	Domain string
}

func GetFullDomain(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 66763 for "get_full_domain" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 66763, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetFullDomainResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetFullDomainResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetFullDomainResult
	err = stack.Unmarshal(&result)
	return "GetFullDomainResult", result, err
}

type GetSaleData_BasicResult struct {
	Marketplace    tlb.MsgAddress
	Nft            tlb.MsgAddress
	Owner          tlb.MsgAddress
	FullPrice      tlb.Int257
	MarketFee      uint64
	RoyaltyAddress tlb.MsgAddress
	RoyaltyAmount  uint64
}

type GetSaleData_GetgemsResult struct {
	Magic            uint64
	IsComplete       bool
	CreatedAt        uint64
	Marketplace      tlb.MsgAddress
	Nft              tlb.MsgAddress
	Owner            tlb.MsgAddress
	FullPrice        tlb.Int257
	MarketFeeAddress tlb.MsgAddress
	MarketFee        uint64
	RoyaltyAddress   tlb.MsgAddress
	RoyaltyAmount    uint64
}

type GetSaleData_GetgemsAuctionResult struct {
	Magic            uint64
	End              bool
	EndTime          uint32
	Marketplace      tlb.MsgAddress
	Nft              tlb.MsgAddress
	Owner            tlb.MsgAddress
	LastBid          uint64
	LastMember       tlb.MsgAddress
	MinStep          uint64
	MarketFeeAddress tlb.MsgAddress
	MpFeeFactor      uint32
	MpFeeBase        uint32
	RoyaltyAddress   tlb.MsgAddress
	RoyaltyFeeFactor uint32
	RoyaltyFeeBase   uint32
	MaxBid           uint64
	MinBid           uint64
	CreatedAt        uint32
	LastBidAt        uint32
	IsCanceled       bool
}

func GetSaleData(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 72748 for "get_sale_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 72748, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetSaleData_BasicResult, DecodeGetSaleData_GetgemsResult, DecodeGetSaleData_GetgemsAuctionResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetSaleData_BasicResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 7 || (stack[0].SumType != "VmStkSlice") || (stack[1].SumType != "VmStkSlice") || (stack[2].SumType != "VmStkSlice") || (stack[3].SumType != "VmStkTinyInt" && stack[3].SumType != "VmStkInt") || (stack[4].SumType != "VmStkTinyInt") || (stack[5].SumType != "VmStkSlice") || (stack[6].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetSaleData_BasicResult
	err = stack.Unmarshal(&result)
	return "GetSaleData_BasicResult", result, err
}

func DecodeGetSaleData_GetgemsResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 11 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkTinyInt") || (stack[3].SumType != "VmStkSlice") || (stack[4].SumType != "VmStkSlice") || (stack[5].SumType != "VmStkSlice") || (stack[6].SumType != "VmStkTinyInt" && stack[6].SumType != "VmStkInt") || (stack[7].SumType != "VmStkSlice") || (stack[8].SumType != "VmStkTinyInt") || (stack[9].SumType != "VmStkSlice") || (stack[10].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetSaleData_GetgemsResult
	err = stack.Unmarshal(&result)
	return "GetSaleData_GetgemsResult", result, err
}

func DecodeGetSaleData_GetgemsAuctionResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 20 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkTinyInt") || (stack[3].SumType != "VmStkSlice") || (stack[4].SumType != "VmStkSlice") || (stack[5].SumType != "VmStkSlice") || (stack[6].SumType != "VmStkTinyInt") || (stack[7].SumType != "VmStkSlice") || (stack[8].SumType != "VmStkTinyInt") || (stack[9].SumType != "VmStkSlice") || (stack[10].SumType != "VmStkTinyInt") || (stack[11].SumType != "VmStkTinyInt") || (stack[12].SumType != "VmStkSlice") || (stack[13].SumType != "VmStkTinyInt") || (stack[14].SumType != "VmStkTinyInt") || (stack[15].SumType != "VmStkTinyInt") || (stack[16].SumType != "VmStkTinyInt") || (stack[17].SumType != "VmStkTinyInt") || (stack[18].SumType != "VmStkTinyInt") || (stack[19].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetSaleData_GetgemsAuctionResult
	err = stack.Unmarshal(&result)
	return "GetSaleData_GetgemsAuctionResult", result, err
}

type GetAuthorityAddressResult struct {
	Address tlb.MsgAddress
}

func GetAuthorityAddress(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 84760 for "get_authority_address" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 84760, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetAuthorityAddressResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetAuthorityAddressResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetAuthorityAddressResult
	err = stack.Unmarshal(&result)
	return "GetAuthorityAddressResult", result, err
}

type GetRevokedTimeResult struct {
	Time uint64
}

func GetRevokedTime(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 97667 for "get_revoked_time" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 97667, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetRevokedTimeResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetRevokedTimeResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetRevokedTimeResult
	err = stack.Unmarshal(&result)
	return "GetRevokedTimeResult", result, err
}

type GetChannelStateResult struct {
	State uint64
}

func GetChannelState(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 106901 for "get_channel_state" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 106901, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetChannelStateResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetChannelStateResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetChannelStateResult
	err = stack.Unmarshal(&result)
	return "GetChannelStateResult", result, err
}

type GetWalletParamsResult struct {
	Seqno     uint32
	Subwallet uint32
	PublicKey tlb.Int257
}

func GetWalletParams(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 130271 for "get_wallet_params" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 130271, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetWalletParamsResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetWalletParamsResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 3 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkTinyInt" && stack[2].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetWalletParamsResult
	err = stack.Unmarshal(&result)
	return "GetWalletParamsResult", result, err
}

type GetStorageParamsResult struct {
	AcceptNewContracts bool
	RatePerMbDay       uint64
	MaxSpan            uint32
	MinimalFileSize    uint64
	MaximalFileSize    uint64
}

func GetStorageParams(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 104346 for "get_storage_params" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 104346, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetStorageParamsResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetStorageParamsResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 5 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkTinyInt") || (stack[3].SumType != "VmStkTinyInt") || (stack[4].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetStorageParamsResult
	err = stack.Unmarshal(&result)
	return "GetStorageParamsResult", result, err
}

type GetStorageContractAddressResult struct {
	StorageContractAddress tlb.MsgAddress
}

func GetStorageContractAddress(ctx context.Context, executor Executor, reqAccountID tongo.AccountID, merkleHash tlb.Int257, fileSize uint64, client tlb.MsgAddress, torrentHash tlb.Int257) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val = tlb.VmStackValue{SumType: "VmStkInt", VmStkInt: merkleHash}
	stack.Put(val)
	val = tlb.VmStackValue{SumType: "VmStkTinyInt", VmStkTinyInt: int64(fileSize)}
	stack.Put(val)
	val, err = tlb.TlbStructToVmCellSlice(client)
	if err != nil {
		return "", nil, err
	}
	stack.Put(val)
	val = tlb.VmStackValue{SumType: "VmStkInt", VmStkInt: torrentHash}
	stack.Put(val)

	// MethodID = 119729 for "get_storage_contract_address" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 119729, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetStorageContractAddressResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetStorageContractAddressResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetStorageContractAddressResult
	err = stack.Unmarshal(&result)
	return "GetStorageContractAddressResult", result, err
}

type GetStorageContractDataResult struct {
	Active        bool
	Balance       uint64
	Provider      tlb.MsgAddress
	MerkleHash    tlb.Int257
	FileSize      uint64
	NextProof     uint64
	RatePerMbDay  uint64
	MaxSpan       uint32
	LastProofTime uint32
	Client        tlb.MsgAddress
	TorrentHash   tlb.Int257
}

func GetStorageContractData(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 86593 for "get_storage_contract_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 86593, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetStorageContractDataResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetStorageContractDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 11 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkSlice") || (stack[3].SumType != "VmStkTinyInt" && stack[3].SumType != "VmStkInt") || (stack[4].SumType != "VmStkTinyInt") || (stack[5].SumType != "VmStkTinyInt") || (stack[6].SumType != "VmStkTinyInt") || (stack[7].SumType != "VmStkTinyInt") || (stack[8].SumType != "VmStkTinyInt") || (stack[9].SumType != "VmStkSlice") || (stack[10].SumType != "VmStkTinyInt" && stack[10].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetStorageContractDataResult
	err = stack.Unmarshal(&result)
	return "GetStorageContractDataResult", result, err
}

type GetTorrentHashResult struct {
	TorrentHash tlb.Int257
}

func GetTorrentHash(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 71463 for "get_torrent_hash" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 71463, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetTorrentHashResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetTorrentHashResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetTorrentHashResult
	err = stack.Unmarshal(&result)
	return "GetTorrentHashResult", result, err
}

type IsActiveResult struct {
	IsActive bool
}

func IsActive(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 122058 for "is_active" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 122058, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeIsActiveResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeIsActiveResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result IsActiveResult
	err = stack.Unmarshal(&result)
	return "IsActiveResult", result, err
}

type GetNextProofInfoResult struct {
	NextProof     uint64
	LastProofTime uint32
	MaxSpan       uint32
}

func GetNextProofInfo(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 81490 for "get_next_proof_info" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 81490, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetNextProofInfoResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetNextProofInfoResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 3 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetNextProofInfoResult
	err = stack.Unmarshal(&result)
	return "GetNextProofInfoResult", result, err
}

type ListNominatorsResult struct {
	Nominators []struct {
		Address              tlb.Bits256
		Amount               uint64
		PendingDepositAmount uint64
		WithdrawRequested    bool
	}
}

func ListNominators(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 111161 for "list_nominators" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 111161, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeListNominatorsResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeListNominatorsResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTuple" && stack[0].SumType != "VmStkNull") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result ListNominatorsResult
	err = stack.Unmarshal(&result)
	return "ListNominatorsResult", result, err
}

type ListVotesResult struct {
	Votes []struct {
		ProposalHash   tlb.Bits256
		VoteCreateTime uint32
	}
}

func ListVotes(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 130309 for "list_votes" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 130309, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeListVotesResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeListVotesResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTuple" && stack[0].SumType != "VmStkNull") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result ListVotesResult
	err = stack.Unmarshal(&result)
	return "ListVotesResult", result, err
}

type GetPoolData_TfResult struct {
	State                    int8
	NominatorsCount          uint32
	StakeAmountSent          int64
	ValidatorAmount          int64
	ValidatorAddress         tlb.Bits256
	ValidatorRewardShare     uint32
	MaxNominatorsCount       uint32
	MinValidatorStake        int64
	MinNominatorStake        int64
	Nominators               tlb.Any
	WithdrawRequests         *AccountLists
	StakeAt                  uint32
	SavedValidatorSetHash    tlb.Bits256
	ValidatorSetChangesCount uint32
	ValidatorSetChangeTime   uint32
	StakeHeldFor             uint32
	ConfigProposalVotings    []struct {
	}
}

func GetPoolData(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 81689 for "get_pool_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 81689, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetPoolData_TfResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetPoolData_TfResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 17 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkTinyInt") || (stack[3].SumType != "VmStkTinyInt") || (stack[4].SumType != "VmStkTinyInt" && stack[4].SumType != "VmStkInt") || (stack[5].SumType != "VmStkTinyInt") || (stack[6].SumType != "VmStkTinyInt") || (stack[7].SumType != "VmStkTinyInt") || (stack[8].SumType != "VmStkTinyInt") || (stack[9].SumType != "VmStkCell") || (stack[10].SumType != "VmStkCell" && stack[10].SumType != "VmStkNull") || (stack[11].SumType != "VmStkTinyInt") || (stack[12].SumType != "VmStkTinyInt" && stack[12].SumType != "VmStkInt") || (stack[13].SumType != "VmStkTinyInt") || (stack[14].SumType != "VmStkTinyInt") || (stack[15].SumType != "VmStkTinyInt") || (stack[16].SumType != "VmStkTuple" && stack[16].SumType != "VmStkNull") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetPoolData_TfResult
	err = stack.Unmarshal(&result)
	return "GetPoolData_TfResult", result, err
}

type GetStakingStatusResult struct {
	StakeAt             uint32
	StakeUntil          uint32
	StakeSent           uint64
	QuerySent           bool
	CouldUnlock         bool
	Locked              bool
	ProxyStakeLockFinal bool
}

func GetStakingStatus(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 123928 for "get_staking_status" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 123928, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetStakingStatusResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetStakingStatusResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 7 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkTinyInt") || (stack[3].SumType != "VmStkTinyInt") || (stack[4].SumType != "VmStkTinyInt") || (stack[5].SumType != "VmStkTinyInt") || (stack[6].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetStakingStatusResult
	err = stack.Unmarshal(&result)
	return "GetStakingStatusResult", result, err
}

type GetPoolStatusResult struct {
	Balance                int64
	BalanceSent            int64
	BalancePendingDeposits int64
	BalancePendingWithdraw int64
	BalanceWithdraw        int64
}

func GetPoolStatus(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 120146 for "get_pool_status" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 120146, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetPoolStatusResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetPoolStatusResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 5 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkTinyInt") || (stack[3].SumType != "VmStkTinyInt") || (stack[4].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetPoolStatusResult
	err = stack.Unmarshal(&result)
	return "GetPoolStatusResult", result, err
}

type GetMember_WhalesNominatorResult struct {
	MemberBalance         int64
	MemberPendingDeposit  int64
	MemberPendingWithdraw int64
	MemberWithdraw        int64
}

func GetMember(ctx context.Context, executor Executor, reqAccountID tongo.AccountID, member tlb.MsgAddress) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val, err = tlb.TlbStructToVmCellSlice(member)
	if err != nil {
		return "", nil, err
	}
	stack.Put(val)

	// MethodID = 70558 for "get_member" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 70558, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetMember_WhalesNominatorResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetMember_WhalesNominatorResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 4 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkTinyInt") || (stack[3].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetMember_WhalesNominatorResult
	err = stack.Unmarshal(&result)
	return "GetMember_WhalesNominatorResult", result, err
}

type GetMembersRaw_WhalesNominatorResult struct {
	Members WhalesNominatorsMembersList
}

func GetMembersRaw(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 89295 for "get_members_raw" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 89295, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetMembersRaw_WhalesNominatorResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetMembersRaw_WhalesNominatorResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 1 || (stack[0].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetMembersRaw_WhalesNominatorResult
	err = stack.Unmarshal(&result)
	return "GetMembersRaw_WhalesNominatorResult", result, err
}

type GetParams_WhalesNominatorResult struct {
	Enabled        bool
	UpdatesEnables bool
	MinStake       int64
	DepositFee     int64
	WithdrawFee    int64
	PoolFee        int64
	ReceiptPrice   int64
}

func GetParams(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 115150 for "get_params" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 115150, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetParams_WhalesNominatorResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetParams_WhalesNominatorResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 7 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkTinyInt") || (stack[3].SumType != "VmStkTinyInt") || (stack[4].SumType != "VmStkTinyInt") || (stack[5].SumType != "VmStkTinyInt") || (stack[6].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetParams_WhalesNominatorResult
	err = stack.Unmarshal(&result)
	return "GetParams_WhalesNominatorResult", result, err
}

type GetTelemintAuctionStateResult struct {
	Bidder  tlb.MsgAddress
	Bid     int64
	BidTs   int64
	MinBid  int64
	EndTime int64
}

func GetTelemintAuctionState(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 122498 for "get_telemint_auction_state" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 122498, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetTelemintAuctionStateResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetTelemintAuctionStateResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 5 || (stack[0].SumType != "VmStkSlice") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkTinyInt") || (stack[3].SumType != "VmStkTinyInt") || (stack[4].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetTelemintAuctionStateResult
	err = stack.Unmarshal(&result)
	return "GetTelemintAuctionStateResult", result, err
}

type GetTelemintAuctionConfigResult struct {
	Beneficiar    tlb.MsgAddress
	InitialMinBid int64
	MaxBid        int64
	MinBidStep    int64
	MinExtendTime int64
	Duration      int64
}

func GetTelemintAuctionConfig(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 129619 for "get_telemint_auction_config" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 129619, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetTelemintAuctionConfigResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetTelemintAuctionConfigResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 6 || (stack[0].SumType != "VmStkSlice") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkTinyInt") || (stack[3].SumType != "VmStkTinyInt") || (stack[4].SumType != "VmStkTinyInt") || (stack[5].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetTelemintAuctionConfigResult
	err = stack.Unmarshal(&result)
	return "GetTelemintAuctionConfigResult", result, err
}

type GetTelemintTokenNameResult struct {
	Beneficiar tlb.Text
}

func GetTelemintTokenName(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 69506 for "get_telemint_token_name" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 69506, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetTelemintTokenNameResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetTelemintTokenNameResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 1 || (stack[0].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetTelemintTokenNameResult
	err = stack.Unmarshal(&result)
	return "GetTelemintTokenNameResult", result, err
}

type GetFinanceData_PoolResult struct {
	TotalBalance           int32
	Supply                 int32
	RequestedForDeposit    int32
	RequestedForWithdrawal int32
}

func GetFinanceData(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 130614 for "get_finance_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 130614, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetFinanceData_PoolResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetFinanceData_PoolResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 4 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkTinyInt" && stack[2].SumType != "VmStkInt") || (stack[3].SumType != "VmStkTinyInt" && stack[3].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetFinanceData_PoolResult
	err = stack.Unmarshal(&result)
	return "GetFinanceData_PoolResult", result, err
}

type GetCurrentRoundDepositMinterResult struct {
	DepositMinter tlb.MsgAddress
}

func GetCurrentRoundDepositMinter(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 116342 for "get_current_round_deposit_minter" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 116342, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetCurrentRoundDepositMinterResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetCurrentRoundDepositMinterResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetCurrentRoundDepositMinterResult
	err = stack.Unmarshal(&result)
	return "GetCurrentRoundDepositMinterResult", result, err
}

type GetCurrentRoundWithdrawalMinterResult struct {
	DepositMinter tlb.MsgAddress
}

func GetCurrentRoundWithdrawalMinter(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 67226 for "get_current_round_withdrawal_minter" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 67226, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetCurrentRoundWithdrawalMinterResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetCurrentRoundWithdrawalMinterResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 1 || (stack[0].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetCurrentRoundWithdrawalMinterResult
	err = stack.Unmarshal(&result)
	return "GetCurrentRoundWithdrawalMinterResult", result, err
}

type GetValidatorControllerDataResult struct {
	State                    int32
	Approved                 bool
	StakeAmountSent          int32
	StakeAt                  int32
	SavedValidatorSetHash    int32
	ValidatorSetChangesCount int32
	ValidatorSetChangeTime   int32
	StakeHeldFor             int32
	BorrowedAmount           int32
	BorrowingTime            int32
}

func GetValidatorControllerData(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 103232 for "get_validator_controller_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 103232, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetValidatorControllerDataResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetValidatorControllerDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 10 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkTinyInt" && stack[2].SumType != "VmStkInt") || (stack[3].SumType != "VmStkTinyInt" && stack[3].SumType != "VmStkInt") || (stack[4].SumType != "VmStkTinyInt" && stack[4].SumType != "VmStkInt") || (stack[5].SumType != "VmStkTinyInt" && stack[5].SumType != "VmStkInt") || (stack[6].SumType != "VmStkTinyInt" && stack[6].SumType != "VmStkInt") || (stack[7].SumType != "VmStkTinyInt" && stack[7].SumType != "VmStkInt") || (stack[8].SumType != "VmStkTinyInt" && stack[8].SumType != "VmStkInt") || (stack[9].SumType != "VmStkTinyInt" && stack[9].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetValidatorControllerDataResult
	err = stack.Unmarshal(&result)
	return "GetValidatorControllerDataResult", result, err
}

type ContractInterface string

// more wallet-related contract interfaces are defined in wallet.go
const (
	Auction             ContractInterface = "auction"
	Domain              ContractInterface = "domain"
	NftEditable         ContractInterface = "nft_editable"
	NftSale             ContractInterface = "nft_sale"
	NftSaleGetgems      ContractInterface = "nft_sale_getgems"
	PaymentChannel      ContractInterface = "payment_channel"
	Pool                ContractInterface = "pool"
	StorageContract     ContractInterface = "storage_contract"
	StorageProvider     ContractInterface = "storage_provider"
	Subscription        ContractInterface = "subscription"
	Telemint            ContractInterface = "telemint"
	Tep62Collection     ContractInterface = "tep62_collection"
	Tep62Item           ContractInterface = "tep62_item"
	Tep66               ContractInterface = "tep66"
	Tep74               ContractInterface = "tep74"
	Tep85               ContractInterface = "tep85"
	TfNominator         ContractInterface = "tf_nominator"
	ValidatorController ContractInterface = "validator_controller"
	Wallet              ContractInterface = "wallet"
	WalletV4R2          ContractInterface = "wallet_v4r2"
	WhalesNominators    ContractInterface = "whales_nominators"
)

type InvokeFn func(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error)

// MethodDescription describes a particular method and provides a function to execute it.
type MethodDescription struct {
	Name string
	// InvokeFn executes this method on a contract and returns parsed execution results.
	InvokeFn InvokeFn
	// ImplementedBy is a list of contract interfaces that implement this method.
	// All contract interfaces share the same method with the same output type.
	ImplementedBy []ContractInterface
	// ImplementedByFn returns an implemented contract interface based on a type hint from InvokeFn.
	// Contract interfaces share the same method name but output is different for each contract interface.
	// Check GetSaleData out as an example.
	ImplementedByFn func(typeName string) ContractInterface
}

var methodInvocationOrder = []MethodDescription{
	{
		Name:          "get_auction_info",
		InvokeFn:      GetAuctionInfo,
		ImplementedBy: []ContractInterface{Auction},
	},
	{
		Name:          "get_authority_address",
		InvokeFn:      GetAuthorityAddress,
		ImplementedBy: []ContractInterface{Tep85},
	},
	{
		Name:          "get_channel_state",
		InvokeFn:      GetChannelState,
		ImplementedBy: []ContractInterface{PaymentChannel},
	},
	{
		Name:          "get_collection_data",
		InvokeFn:      GetCollectionData,
		ImplementedBy: []ContractInterface{Tep62Collection},
	},
	{
		Name:          "get_current_round_deposit_minter",
		InvokeFn:      GetCurrentRoundDepositMinter,
		ImplementedBy: []ContractInterface{Pool},
	},
	{
		Name:          "get_current_round_withdrawal_minter",
		InvokeFn:      GetCurrentRoundWithdrawalMinter,
		ImplementedBy: []ContractInterface{Pool},
	},
	{
		Name:          "get_domain",
		InvokeFn:      GetDomain,
		ImplementedBy: []ContractInterface{Domain},
	},
	{
		Name:          "get_editor",
		InvokeFn:      GetEditor,
		ImplementedBy: []ContractInterface{NftEditable},
	},
	{
		Name:          "get_finance_data",
		InvokeFn:      GetFinanceData,
		ImplementedBy: []ContractInterface{Pool},
	},
	{
		Name:          "get_full_domain",
		InvokeFn:      GetFullDomain,
		ImplementedBy: []ContractInterface{Domain},
	},
	{
		Name:          "get_jetton_data",
		InvokeFn:      GetJettonData,
		ImplementedBy: []ContractInterface{Tep74},
	},
	{
		Name:          "get_last_fill_up_time",
		InvokeFn:      GetLastFillUpTime,
		ImplementedBy: []ContractInterface{Domain},
	},
	{
		Name:     "get_members_raw",
		InvokeFn: GetMembersRaw,
		ImplementedByFn: func(typeHint string) ContractInterface {
			switch typeHint {
			case "GetMembersRaw_WhalesNominatorResult":
				return WhalesNominators
			}
			return ""
		},
	},
	{
		Name:          "get_next_proof_info",
		InvokeFn:      GetNextProofInfo,
		ImplementedBy: []ContractInterface{StorageContract},
	},
	{
		Name:          "get_nft_data",
		InvokeFn:      GetNftData,
		ImplementedBy: []ContractInterface{Tep62Item},
	},
	{
		Name:     "get_params",
		InvokeFn: GetParams,
		ImplementedByFn: func(typeHint string) ContractInterface {
			switch typeHint {
			case "GetParams_WhalesNominatorResult":
				return WhalesNominators
			}
			return ""
		},
	},
	{
		Name:          "get_plugin_list",
		InvokeFn:      GetPluginList,
		ImplementedBy: []ContractInterface{WalletV4R2},
	},
	{
		Name:          "get_pool_data",
		InvokeFn:      GetPoolData,
		ImplementedBy: []ContractInterface{TfNominator},
	},
	{
		Name:          "get_pool_status",
		InvokeFn:      GetPoolStatus,
		ImplementedBy: []ContractInterface{WhalesNominators},
	},
	{
		Name:          "get_public_key",
		InvokeFn:      GetPublicKey,
		ImplementedBy: []ContractInterface{StorageProvider, Wallet},
	},
	{
		Name:          "get_revoked_time",
		InvokeFn:      GetRevokedTime,
		ImplementedBy: []ContractInterface{Tep85},
	},
	{
		Name:     "get_sale_data",
		InvokeFn: GetSaleData,
		ImplementedByFn: func(typeHint string) ContractInterface {
			switch typeHint {
			case "GetSaleData_BasicResult":
				return NftSale
			case "GetSaleData_GetgemsAuctionResult":
				return NftSaleGetgems
			case "GetSaleData_GetgemsResult":
				return NftSaleGetgems
			}
			return ""
		},
	},
	{
		Name:          "get_staking_status",
		InvokeFn:      GetStakingStatus,
		ImplementedBy: []ContractInterface{WhalesNominators},
	},
	{
		Name:          "get_storage_contract_data",
		InvokeFn:      GetStorageContractData,
		ImplementedBy: []ContractInterface{StorageContract},
	},
	{
		Name:          "get_storage_params",
		InvokeFn:      GetStorageParams,
		ImplementedBy: []ContractInterface{StorageProvider},
	},
	{
		Name:          "get_subscription_data",
		InvokeFn:      GetSubscriptionData,
		ImplementedBy: []ContractInterface{Subscription},
	},
	{
		Name:          "get_subwallet_id",
		InvokeFn:      GetSubwalletId,
		ImplementedBy: []ContractInterface{WalletV4R2},
	},
	{
		Name:          "get_telemint_auction_config",
		InvokeFn:      GetTelemintAuctionConfig,
		ImplementedBy: []ContractInterface{Telemint},
	},
	{
		Name:          "get_telemint_auction_state",
		InvokeFn:      GetTelemintAuctionState,
		ImplementedBy: []ContractInterface{Telemint},
	},
	{
		Name:          "get_telemint_token_name",
		InvokeFn:      GetTelemintTokenName,
		ImplementedBy: []ContractInterface{Telemint},
	},
	{
		Name:          "get_torrent_hash",
		InvokeFn:      GetTorrentHash,
		ImplementedBy: []ContractInterface{StorageContract},
	},
	{
		Name:          "get_validator_controller_data",
		InvokeFn:      GetValidatorControllerData,
		ImplementedBy: []ContractInterface{ValidatorController},
	},
	{
		Name:          "get_wallet_data",
		InvokeFn:      GetWalletData,
		ImplementedBy: []ContractInterface{Tep74},
	},
	{
		Name:          "get_wallet_params",
		InvokeFn:      GetWalletParams,
		ImplementedBy: []ContractInterface{StorageProvider},
	},
	{
		Name:          "is_active",
		InvokeFn:      IsActive,
		ImplementedBy: []ContractInterface{StorageContract},
	},
	{
		Name:          "list_nominators",
		InvokeFn:      ListNominators,
		ImplementedBy: []ContractInterface{TfNominator},
	},
	{
		Name:          "list_votes",
		InvokeFn:      ListVotes,
		ImplementedBy: []ContractInterface{TfNominator},
	},
	{
		Name:          "royalty_params",
		InvokeFn:      RoyaltyParams,
		ImplementedBy: []ContractInterface{Tep66},
	},
	{
		Name:          "seqno",
		InvokeFn:      Seqno,
		ImplementedBy: []ContractInterface{StorageProvider, Wallet},
	},
}
