package abi

// Code autogenerated. DO NOT EDIT.

import (
	"context"
	"fmt"
	"github.com/tonkeeper/tongo"
	"github.com/tonkeeper/tongo/boc"
	"github.com/tonkeeper/tongo/tlb"
)

type ContentData struct {
	tlb.SumType
	Snake struct {
		Data tlb.SnakeData
	} `tlbSumType:"#00"`
	Chunks struct {
		Data tlb.ChunkedData
	} `tlbSumType:"#01"`
}

type FullContent struct {
	tlb.SumType
	Onchain struct {
		Data tlb.HashmapE[tlb.Bits256, tlb.Ref[ContentData]]
	} `tlbSumType:"#00"`
	Offchain struct {
		Uri tlb.Text
	} `tlbSumType:"#01"`
}

type ClosingConfig struct {
	QuarantinDuration        uint32
	MisbehaviorFine          tlb.Grams
	ConditionalCloseDuration uint32
}

type ConditionalPayment struct {
	Amount    tlb.Grams
	Condition tlb.Any
}

type PaymentConfig struct {
	ExcessFee tlb.Grams
	DestA     tlb.MsgAddress
	DestB     tlb.MsgAddress
}

type QuarantinedState struct {
	StateA           SemiChannelBody
	StateB           SemiChannelBody
	QuarantineStarts uint32
	StateCommitedByA bool
}

type SemiChannel struct {
	Magic            tlb.Magic `tlb:"#43685374"`
	ChannelId        tlb.Uint128
	Data             SemiChannelBody
	CounterpartyData tlb.Maybe[tlb.Ref[SemiChannelBody]]
}

type SemiChannelBody struct {
	Seqno        uint64
	Sent         tlb.Grams
	Conditionals tlb.HashmapE[tlb.Uint32, ConditionalPayment]
}

type SignedSemiChannel struct {
	Signature tlb.Bits512
	State     SemiChannel
}

type Storage struct {
	BalanceA       tlb.Grams
	BalanceB       tlb.Grams
	KeyA           tlb.Uint256
	KeyB           tlb.Uint256
	ChannelId      tlb.Uint128
	Config         tlb.Ref[ClosingConfig]
	CommitedSeqnoA uint32
	CommitedSeqnoB uint32
	Quarantin      tlb.Maybe[tlb.Ref[QuarantinedState]]
	Payments       tlb.Ref[PaymentConfig]
}

type TorrentInfo struct {
	PieceSize      uint32
	FileSize       uint64
	RootHash       tlb.Uint256
	HeaderSize     uint64
	HeaderHash     tlb.Uint256
	MicrochunkHash tlb.Maybe[tlb.Uint256]
	Description    tlb.Text
}

type NftRoyaltyParams struct {
	Numerator   uint16
	Denominator uint16
	Destination tlb.MsgAddress
}

type TeleitemAuctionConfig struct {
	BeneficiarAddress tlb.MsgAddress
	InitialMinBid     tlb.Grams
	MaxBid            tlb.Grams
	MinBidStep        uint8
	MinExtendTime     uint32
	Duration          uint32
}

type TelemintData struct {
	Touched           bool
	SubwalletId       uint32
	PublicKey         tlb.Bits256
	CollectionContent tlb.Ref[tlb.Any]
	NftItemCode       tlb.Ref[tlb.Any]
	RoyaltyParams     tlb.Ref[NftRoyaltyParams]
}

type TelemintRestrictions struct {
	ForceSenderAddress   tlb.Maybe[tlb.MsgAddress]
	RewriteSenderAddress tlb.Maybe[tlb.MsgAddress]
}

type TelemintUnsignedDeploy struct {
	SubwalletId   uint32
	ValidSince    uint32
	ValidTill     uint32
	Username      tlb.FixedLengthText
	Content       tlb.Ref[tlb.Any]
	AuctionConfig tlb.Ref[TeleitemAuctionConfig]
	RoyaltyParams tlb.Maybe[tlb.Ref[NftRoyaltyParams]]
}

type TelemintUnsignedDeployV2 struct {
	SubwalletId   uint32
	ValidSince    uint32
	ValidTill     uint32
	TokenName     tlb.FixedLengthText
	Content       tlb.Ref[tlb.Any]
	AuctionConfig tlb.Ref[TeleitemAuctionConfig]
	RoyaltyParams tlb.Maybe[tlb.Ref[NftRoyaltyParams]]
	Restrictions  tlb.Maybe[tlb.Ref[TelemintRestrictions]]
}

type WhalesNominatorsMember struct {
	ProfitPerCoin      tlb.Int128
	Balance            tlb.Grams
	PendingWithdraw    tlb.Grams
	PendingWithdrawAll bool
	PendingDeposit     tlb.Grams
	MemberWithdraw     tlb.Grams
}

type WhalesNominatorsMembersList struct {
	List tlb.Hashmap[tlb.Bits256, WhalesNominatorsMember]
}

type TextCommentMsgBody struct {
	Text tlb.Text
}

type ProveOwnershipMsgBody struct {
	QueryId        uint64
	Dest           tlb.MsgAddress
	ForwardPayload tlb.Ref[tlb.Any]
	WithContent    bool
}

type NftOwnershipAssignedMsgBody struct {
	QueryId        uint64
	PrevOwner      tlb.MsgAddress
	ForwardPayload tlb.EitherRef[tlb.Any]
}

type OwnershipProofMsgBody struct {
	QueryId   uint64
	ItemId    tlb.Uint256
	Owner     tlb.MsgAddress
	Data      tlb.Ref[tlb.Any]
	RevokedAt uint64
	Content   tlb.Maybe[tlb.Ref[tlb.Any]]
}

type ChallengeQuarantinedChannelStateMsgBody struct {
	ChallengedByA bool
	Signature     tlb.Bits512
	Tag           uint32
	ChannelId     tlb.Uint128
	SchA          tlb.Ref[SignedSemiChannel]
	SchB          tlb.Ref[SignedSemiChannel]
}

type SbtOwnerInfoMsgBody struct {
	QueryId   uint64
	ItemId    tlb.Uint256
	Initiator tlb.MsgAddress
	Owner     tlb.MsgAddress
	Data      tlb.Ref[tlb.Any]
	RevokedAt uint64
	Content   tlb.Maybe[tlb.Ref[tlb.Any]]
}

type InitPaymentChannelMsgBody struct {
	IsA       bool
	Signature tlb.Bits512
	Tag       uint32
	ChannelId tlb.Uint128
	BalanceA  tlb.Grams
	BalanceB  tlb.Grams
}

type JettonTransferMsgBody struct {
	QueryId             uint64
	Amount              tlb.VarUInteger16
	Destination         tlb.MsgAddress
	ResponseDestination tlb.MsgAddress
	CustomPayload       tlb.Maybe[tlb.Ref[tlb.Any]]
	ForwardTonAmount    tlb.VarUInteger16
	ForwardPayload      tlb.EitherRef[tlb.Any]
}

type OfferStorageContractMsgBody struct {
	QueryId uint64
}

type JettonInternalTransferMsgBody struct {
	QueryId          uint64
	Amount           tlb.VarUInteger16
	From             tlb.MsgAddress
	ResponseAddress  tlb.MsgAddress
	ForwardTonAmount tlb.VarUInteger16
}

type SbtDestroyMsgBody struct {
	QueryId uint64
}

type StartUncooperativeChannelCloseMsgBody struct {
	SignedByA bool
	Signature tlb.Bits512
	Tag       uint32
	ChannelId tlb.Uint128
	SchA      tlb.Ref[SignedSemiChannel]
	SchB      tlb.Ref[SignedSemiChannel]
}

type FinishUncooperativeChannelCloseMsgBody struct{}

type TeleitemDeployMsgBody struct {
	SenderAddress tlb.MsgAddress
	Bid           tlb.Grams
	Username      tlb.FixedLengthText
	Content       tlb.Ref[tlb.Any]
	AuctionConfig tlb.Ref[TeleitemAuctionConfig]
	RoyaltyParams tlb.Ref[NftRoyaltyParams]
}

type GetStaticDataMsgBody struct {
	QueryId uint64
}

type TeleitemCancelAuctionMsgBody struct {
	QueryId int64
}

type ProofStorageMsgBody struct {
	QueryId       uint64
	FileDictProof tlb.Ref[tlb.Any]
}

type TelemintDeployMsgBody struct {
	Sig tlb.Bits512
	Msg TelemintUnsignedDeploy
}

type TelemintDeployV2MsgBody struct {
	Sig tlb.Bits512
	Msg TelemintUnsignedDeployV2
}

type StorageWithdrawMsgBody struct {
	QueryId uint64
}

type TeleitemStartAuctionMsgBody struct {
	QueryId       int64
	AuctionConfig tlb.Ref[TeleitemAuctionConfig]
}

type UpdatePubkeyMsgBody struct {
	QueryId   uint64
	NewPubkey tlb.Bits256
}

type UpdateStorageParamsMsgBody struct {
	QueryId            uint64
	AcceptNewContracts bool
	RatePerMbDay       tlb.Grams
	MaxSpan            uint32
	MinimalFileSize    uint64
	MaximalFileSize    uint64
}

type ChannelCooperativeCloseMsgBody struct {
	SigA      tlb.Ref[tlb.Bits512]
	SigB      tlb.Ref[tlb.Bits512]
	Tag       uint32
	ChannelId tlb.Uint128
	BalanceA  tlb.Grams
	BalanceB  tlb.Grams
	SeqnoA    uint64
	SeqnoB    uint64
}

type JettonBurnMsgBody struct {
	QueryId             uint64
	Amount              tlb.VarUInteger16
	ResponseDestination tlb.MsgAddress
	CustomPayload       tlb.Maybe[tlb.Ref[tlb.Any]]
}

type NftTransferMsgBody struct {
	QueryId             uint64
	NewOwner            tlb.MsgAddress
	ResponseDestination tlb.MsgAddress
	CustomPayload       tlb.Maybe[tlb.Ref[tlb.Any]]
	ForwardAmount       tlb.VarUInteger16
	ForwardPayload      tlb.EitherRef[tlb.Any]
}

type WalletPluginDestructMsgBody struct {
	QueryId uint64
}

type SettleChannelConditionalsMsgBody struct {
	FromA                bool
	Signature            tlb.Bits512
	Tag                  uint32
	ChannelId            tlb.Uint128
	ConditionalsToSettle tlb.HashmapE[tlb.Uint32, tlb.Any]
}

type TopUpChannelBalanceMsgBody struct {
	AddA tlb.Grams
	AddB tlb.Grams
}

type GetRoyaltyParamsMsgBody struct {
	QueryId uint64
}

type SbtRevokeMsgBody struct {
	QueryId uint64
}

type PaymentRequestMsgBody struct {
	QueryId uint64
	Amount  tlb.CurrencyCollection
}

type ChannelCooperativeCommitMsgBody struct {
	SigA      tlb.Ref[tlb.Bits512]
	SigB      tlb.Ref[tlb.Bits512]
	Tag       uint32
	ChannelId tlb.Uint128
	SeqnoA    uint64
	SeqnoB    uint64
}

type CloseStorageContractMsgBody struct {
	QueryId uint64
}

type AcceptStorageContractMsgBody struct {
	QueryId uint64
}

type WhalesNominatorsDepositMsgBody struct {
	QueryId int64
	Gas     tlb.Grams
}

type ReportStaticDataMsgBody struct {
	QueryId    uint64
	Index      tlb.Uint256
	Collection tlb.MsgAddress
}

type ReportRoyaltyParamsMsgBody struct {
	QueryId     uint64
	Numerator   uint16
	Denominator uint16
	Destination tlb.MsgAddress
}

type StorageRewardWithdrawalMsgBody struct {
	QueryId uint64
}

type StorageContractTerminatedMsgBody struct {
	CurLt       uint64
	TorrentHash tlb.Bits256
}

type SbtRequestOwnerMsgBody struct {
	QueryId        uint64
	Dest           tlb.MsgAddress
	ForwardPayload tlb.Ref[tlb.Any]
	WithContent    bool
}

type StorageContractConfirmedMsgBody struct {
	CurLt       uint64
	TorrentHash tlb.Bits256
}

type ExcessMsgBody struct {
	QueryId uint64
}

type WhalesNominatorsWithdrawMsgBody struct {
	QueryId int64
	Gas     tlb.Grams
	Amount  tlb.Grams
}

type ChannelClosedMsgBody struct {
	ChannelId tlb.Uint128
}

type WalletPluginDestructResponseMsgBody struct {
	QueryId uint64
}

type DeployStorageContractMsgBody struct {
	QueryId         uint64
	Info            tlb.Ref[TorrentInfo]
	MerkleHash      tlb.Bits256
	ExpectedRate    tlb.Grams
	ExpectedMaxSpan uint32
}

type PaymentRequestResponseMsgBody struct {
	QueryId uint64
}

func MessageDecoder(cell *boc.Cell) (string, any, error) {
	tag, err := cell.ReadUint(32)
	if err != nil {
		return "", nil, err
	}
	switch tag {
	case 0x0:
		var res TextCommentMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "TextComment", res, err
	case 0x4ded148:
		var res ProveOwnershipMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "ProveOwnership", res, err
	case 0x5138d91:
		var res NftOwnershipAssignedMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "NftOwnershipAssigned", res, err
	case 0x524c7ae:
		var res OwnershipProofMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "OwnershipProof", res, err
	case 0x88eaa32:
		var res ChallengeQuarantinedChannelStateMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "ChallengeQuarantinedChannelState", res, err
	case 0xdd607e3:
		var res SbtOwnerInfoMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "SbtOwnerInfo", res, err
	case 0xe0620c2:
		var res InitPaymentChannelMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "InitPaymentChannel", res, err
	case 0xf8a7ea5:
		var res JettonTransferMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "JettonTransfer", res, err
	case 0x107c49ef:
		var res OfferStorageContractMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "OfferStorageContract", res, err
	case 0x178d4519:
		var res JettonInternalTransferMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "JettonInternalTransfer", res, err
	case 0x1f04537a:
		var res SbtDestroyMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "SbtDestroy", res, err
	case 0x1f151acf:
		var res StartUncooperativeChannelCloseMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "StartUncooperativeChannelClose", res, err
	case 0x25432a91:
		var res FinishUncooperativeChannelCloseMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "FinishUncooperativeChannelClose", res, err
	case 0x299a3e15:
		var res TeleitemDeployMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "TeleitemDeploy", res, err
	case 0x2fcb26a2:
		var res GetStaticDataMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "GetStaticData", res, err
	case 0x371638ae:
		var res TeleitemCancelAuctionMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "TeleitemCancelAuction", res, err
	case 0x419d5d4d:
		var res ProofStorageMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "ProofStorage", res, err
	case 0x4637289a:
		var res TelemintDeployMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "TelemintDeploy", res, err
	case 0x4637289b:
		var res TelemintDeployV2MsgBody
		err = tlb.Unmarshal(cell, &res)
		return "TelemintDeployV2", res, err
	case 0x46ed2e94:
		var res StorageWithdrawMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "StorageWithdraw", res, err
	case 0x487a8e81:
		var res TeleitemStartAuctionMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "TeleitemStartAuction", res, err
	case 0x53f34cd6:
		var res UpdatePubkeyMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "UpdatePubkey", res, err
	case 0x54cbf19b:
		var res UpdateStorageParamsMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "UpdateStorageParams", res, err
	case 0x5577587e:
		var res ChannelCooperativeCloseMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "ChannelCooperativeClose", res, err
	case 0x595f07bc:
		var res JettonBurnMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "JettonBurn", res, err
	case 0x5fcc3d14:
		var res NftTransferMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "NftTransfer", res, err
	case 0x64737472:
		var res WalletPluginDestructMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "WalletPluginDestruct", res, err
	case 0x66f6f069:
		var res SettleChannelConditionalsMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "SettleChannelConditionals", res, err
	case 0x67c7d281:
		var res TopUpChannelBalanceMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "TopUpChannelBalance", res, err
	case 0x693d3950:
		var res GetRoyaltyParamsMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "GetRoyaltyParams", res, err
	case 0x6f89f5e3:
		var res SbtRevokeMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "SbtRevoke", res, err
	case 0x706c7567:
		var res PaymentRequestMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "PaymentRequest", res, err
	case 0x79a126ef:
		var res ChannelCooperativeCommitMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "ChannelCooperativeCommit", res, err
	case 0x79f937ea:
		var res CloseStorageContractMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "CloseStorageContract", res, err
	case 0x7a361688:
		var res AcceptStorageContractMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "AcceptStorageContract", res, err
	case 0x7bcd1fef:
		var res WhalesNominatorsDepositMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "WhalesNominatorsDeposit", res, err
	case 0x8b771735:
		var res ReportStaticDataMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "ReportStaticData", res, err
	case 0xa8cb00ad:
		var res ReportRoyaltyParamsMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "ReportRoyaltyParams", res, err
	case 0xa91baf56:
		var res StorageRewardWithdrawalMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "StorageRewardWithdrawal", res, err
	case 0xb6236d63:
		var res StorageContractTerminatedMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "StorageContractTerminated", res, err
	case 0xd0c3bfea:
		var res SbtRequestOwnerMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "SbtRequestOwner", res, err
	case 0xd4caedcd:
		var res StorageContractConfirmedMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "StorageContractConfirmed", res, err
	case 0xd53276db:
		var res ExcessMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "Excess", res, err
	case 0xda803efd:
		var res WhalesNominatorsWithdrawMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "WhalesNominatorsWithdraw", res, err
	case 0xdddc88ba:
		var res ChannelClosedMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "ChannelClosed", res, err
	case 0xe4737472:
		var res WalletPluginDestructResponseMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "WalletPluginDestructResponse", res, err
	case 0xe4748df1:
		var res DeployStorageContractMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "DeployStorageContract", res, err
	case 0xf06c7567:
		var res PaymentRequestResponseMsgBody
		err = tlb.Unmarshal(cell, &res)
		return "PaymentRequestResponse", res, err
	}
	return "", nil, fmt.Errorf("invalid message tag")
}

var KnownGetMethodsDecoder = map[string][]func(tlb.VmStack) (string, any, error){
	"seqno":                        {DecodeSeqnoResult},
	"get_public_key":               {DecodeGetPublicKeyResult},
	"get_subwallet_id":             {DecodeGetSubwalletIdResult},
	"get_plugin_list":              {DecodeGetPluginListResult},
	"is_plugin_installed":          {DecodeIsPluginInstalledResult},
	"get_nft_data":                 {DecodeGetNftDataResult},
	"get_nft_content":              {DecodeGetNftContentResult},
	"get_collection_data":          {DecodeGetCollectionDataResult},
	"get_nft_address_by_index":     {DecodeGetNftAddressByIndexResult},
	"royalty_params":               {DecodeRoyaltyParamsResult},
	"get_jetton_data":              {DecodeGetJettonDataResult},
	"get_wallet_address":           {DecodeGetWalletAddressResult},
	"get_wallet_data":              {DecodeGetWalletDataResult},
	"dnsresolve":                   {DecodeDnsresolve_RecordResult, DecodeDnsresolve_RecordsResult},
	"get_sale_data":                {DecodeGetSaleData_BasicResult, DecodeGetSaleData_GetgemsResult, DecodeGetSaleData_GetgemsAuctionResult},
	"get_authority_address":        {DecodeGetAuthorityAddressResult},
	"get_revoked_time":             {DecodeGetRevokedTimeResult},
	"get_channel_state":            {DecodeGetChannelStateResult},
	"get_wallet_params":            {DecodeGetWalletParamsResult},
	"get_storage_params":           {DecodeGetStorageParamsResult},
	"get_storage_contract_address": {DecodeGetStorageContractAddressResult},
	"get_storage_contract_data":    {DecodeGetStorageContractDataResult},
	"get_torrent_hash":             {DecodeGetTorrentHashResult},
	"is_active":                    {DecodeIsActiveResult},
	"get_next_proof_info":          {DecodeGetNextProofInfoResult},
	"list_nominators":              {DecodeListNominatorsResult},
	"list_votes":                   {DecodeListVotesResult},
	"get_pool_data":                {DecodeGetPoolData_TfResult},
	"get_staking_status":           {DecodeGetStakingStatusResult},
	"get_pool_status":              {DecodeGetPoolStatusResult},
	"get_member":                   {DecodeGetMember_WhalesNominatorResult},
	"get_members_raw":              {DecodeGetMembersRaw_WhalesNominatorResult},
	"get_params":                   {DecodeGetParams_WhalesNominatorResult},
	"get_telemint_auction_state":   {DecodeGetTelemintAuctionStateResult},
	"get_telemint_auction_config":  {DecodeGetTelemintAuctionConfigResult},
	"get_telemint_token_name":      {DecodeGetTelemintTokenNameResult},
}

var KnownSimpleGetMethods = map[int][]func(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error){
	69506:  {GetTelemintTokenName},
	71463:  {GetTorrentHash},
	72748:  {GetSaleData},
	78748:  {GetPublicKey},
	81467:  {GetSubwalletId},
	81490:  {GetNextProofInfo},
	81689:  {GetPoolData},
	84760:  {GetAuthorityAddress},
	85143:  {Seqno},
	85719:  {RoyaltyParams},
	86593:  {GetStorageContractData},
	89295:  {GetMembersRaw},
	97026:  {GetWalletData},
	97667:  {GetRevokedTime},
	102351: {GetNftData},
	102491: {GetCollectionData},
	104346: {GetStorageParams},
	106029: {GetJettonData},
	106901: {GetChannelState},
	107653: {GetPluginList},
	111161: {ListNominators},
	115150: {GetParams},
	120146: {GetPoolStatus},
	122058: {IsActive},
	122498: {GetTelemintAuctionState},
	123928: {GetStakingStatus},
	129619: {GetTelemintAuctionConfig},
	130271: {GetWalletParams},
	130309: {ListVotes},
}

var ResultTypes = []interface{}{
	&Dnsresolve_RecordResult{},
	&Dnsresolve_RecordsResult{},
	&GetAuthorityAddressResult{},
	&GetChannelStateResult{},
	&GetCollectionDataResult{},
	&GetJettonDataResult{},
	&GetMember_WhalesNominatorResult{},
	&GetMembersRaw_WhalesNominatorResult{},
	&GetNextProofInfoResult{},
	&GetNftAddressByIndexResult{},
	&GetNftContentResult{},
	&GetNftDataResult{},
	&GetParams_WhalesNominatorResult{},
	&GetPluginListResult{},
	&GetPoolData_TfResult{},
	&GetPoolStatusResult{},
	&GetPublicKeyResult{},
	&GetRevokedTimeResult{},
	&GetSaleData_BasicResult{},
	&GetSaleData_GetgemsAuctionResult{},
	&GetSaleData_GetgemsResult{},
	&GetStakingStatusResult{},
	&GetStorageContractAddressResult{},
	&GetStorageContractDataResult{},
	&GetStorageParamsResult{},
	&GetSubwalletIdResult{},
	&GetTelemintAuctionConfigResult{},
	&GetTelemintAuctionStateResult{},
	&GetTelemintTokenNameResult{},
	&GetTorrentHashResult{},
	&GetWalletAddressResult{},
	&GetWalletDataResult{},
	&GetWalletParamsResult{},
	&IsActiveResult{},
	&IsPluginInstalledResult{},
	&ListNominatorsResult{},
	&ListVotesResult{},
	&RoyaltyParamsResult{},
	&SeqnoResult{},
}

type Executor interface {
	RunSmcMethodByID(ctx context.Context, accountID tongo.AccountID, methodID int, params tlb.VmStack) (uint32, tlb.VmStack, error)
}

type SeqnoResult struct {
	State uint32
}

func Seqno(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 85143 for "seqno" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 85143, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeSeqnoResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeSeqnoResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result SeqnoResult
	err = stack.Unmarshal(&result)
	return "SeqnoResult", result, nil
}

type GetPublicKeyResult struct {
	PublicKey tlb.Int257
}

func GetPublicKey(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 78748 for "get_public_key" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 78748, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetPublicKeyResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetPublicKeyResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetPublicKeyResult
	err = stack.Unmarshal(&result)
	return "GetPublicKeyResult", result, nil
}

type GetSubwalletIdResult struct {
	SubwalletId uint32
}

func GetSubwalletId(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 81467 for "get_subwallet_id" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 81467, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetSubwalletIdResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetSubwalletIdResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetSubwalletIdResult
	err = stack.Unmarshal(&result)
	return "GetSubwalletIdResult", result, nil
}

type GetPluginListResult struct {
	Plugins []struct {
		Workchain int32
		Address   tlb.Bits256
	}
}

func GetPluginList(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 107653 for "get_plugin_list" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 107653, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetPluginListResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetPluginListResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTuple" && stack[0].SumType != "VmStkNull") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetPluginListResult
	err = stack.Unmarshal(&result)
	return "GetPluginListResult", result, nil
}

type IsPluginInstalledResult struct {
	Success bool
}

func IsPluginInstalled(ctx context.Context, executor Executor, reqAccountID tongo.AccountID, workchain int32, addrHash tlb.Int257) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val = tlb.VmStackValue{SumType: "VmStkTinyInt", VmStkTinyInt: int64(workchain)}
	stack.Put(val)
	val = tlb.VmStackValue{SumType: "VmStkInt", VmStkInt: addrHash}
	stack.Put(val)

	// MethodID = 76407 for "is_plugin_installed" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 76407, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeIsPluginInstalledResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeIsPluginInstalledResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result IsPluginInstalledResult
	err = stack.Unmarshal(&result)
	return "IsPluginInstalledResult", result, nil
}

type GetNftDataResult struct {
	Init              bool
	Index             tlb.Int257
	CollectionAddress tlb.MsgAddress
	OwnerAddress      tlb.MsgAddress
	IndividualContent tlb.Any
}

func GetNftData(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 102351 for "get_nft_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 102351, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetNftDataResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetNftDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 5 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt" && stack[1].SumType != "VmStkInt") || (stack[2].SumType != "VmStkSlice") || (stack[3].SumType != "VmStkSlice") || (stack[4].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetNftDataResult
	err = stack.Unmarshal(&result)
	return "GetNftDataResult", result, nil
}

type GetNftContentResult struct {
	Content FullContent
}

func GetNftContent(ctx context.Context, executor Executor, reqAccountID tongo.AccountID, index tlb.Int257, individualContent tlb.Any) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val = tlb.VmStackValue{SumType: "VmStkInt", VmStkInt: index}
	stack.Put(val)
	val, err = tlb.TlbStructToVmCell(individualContent)
	if err != nil {
		return "", nil, err
	}
	stack.Put(val)

	// MethodID = 68445 for "get_nft_content" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 68445, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetNftContentResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetNftContentResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetNftContentResult
	err = stack.Unmarshal(&result)
	return "GetNftContentResult", result, nil
}

type GetCollectionDataResult struct {
	NextItemIndex     tlb.Int257
	CollectionContent tlb.Any
	OwnerAddress      tlb.MsgAddress
}

func GetCollectionData(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 102491 for "get_collection_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 102491, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetCollectionDataResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetCollectionDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 3 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkCell") || (stack[2].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetCollectionDataResult
	err = stack.Unmarshal(&result)
	return "GetCollectionDataResult", result, nil
}

type GetNftAddressByIndexResult struct {
	Address tlb.MsgAddress
}

func GetNftAddressByIndex(ctx context.Context, executor Executor, reqAccountID tongo.AccountID, index tlb.Int257) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val = tlb.VmStackValue{SumType: "VmStkInt", VmStkInt: index}
	stack.Put(val)

	// MethodID = 92067 for "get_nft_address_by_index" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 92067, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetNftAddressByIndexResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetNftAddressByIndexResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetNftAddressByIndexResult
	err = stack.Unmarshal(&result)
	return "GetNftAddressByIndexResult", result, nil
}

type RoyaltyParamsResult struct {
	Numerator   uint16
	Denominator uint16
	Destination tlb.MsgAddress
}

func RoyaltyParams(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 85719 for "royalty_params" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 85719, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeRoyaltyParamsResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeRoyaltyParamsResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 3 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result RoyaltyParamsResult
	err = stack.Unmarshal(&result)
	return "RoyaltyParamsResult", result, nil
}

type GetJettonDataResult struct {
	TotalSupply      tlb.Int257
	Mintable         int8
	AdminAddress     tlb.MsgAddress
	JettonContent    tlb.Any
	JettonWalletCode tlb.Any
}

func GetJettonData(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 106029 for "get_jetton_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 106029, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetJettonDataResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetJettonDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 5 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkSlice") || (stack[3].SumType != "VmStkCell") || (stack[4].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetJettonDataResult
	err = stack.Unmarshal(&result)
	return "GetJettonDataResult", result, nil
}

type GetWalletAddressResult struct {
	JettonWalletAddress tlb.MsgAddress
}

func GetWalletAddress(ctx context.Context, executor Executor, reqAccountID tongo.AccountID, ownerAddress tlb.MsgAddress) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val, err = tlb.TlbStructToVmCellSlice(ownerAddress)
	if err != nil {
		return "", nil, err
	}
	stack.Put(val)

	// MethodID = 103289 for "get_wallet_address" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 103289, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetWalletAddressResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetWalletAddressResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetWalletAddressResult
	err = stack.Unmarshal(&result)
	return "GetWalletAddressResult", result, nil
}

type GetWalletDataResult struct {
	Balance          tlb.Int257
	Owner            tlb.MsgAddress
	Jetton           tlb.MsgAddress
	JettonWalletCode tlb.Any
}

func GetWalletData(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 97026 for "get_wallet_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 97026, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetWalletDataResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetWalletDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 4 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") || (stack[1].SumType != "VmStkSlice") || (stack[2].SumType != "VmStkSlice") || (stack[3].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetWalletDataResult
	err = stack.Unmarshal(&result)
	return "GetWalletDataResult", result, nil
}

type Dnsresolve_RecordResult struct {
	ResolvedBits int64
	Result       tlb.DNSRecord
}

type Dnsresolve_RecordsResult struct {
	ResolvedBits int64
	Result       tlb.DNSRecordSet
}

func Dnsresolve(ctx context.Context, executor Executor, reqAccountID tongo.AccountID, domain []byte, category tlb.Int257) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val, err = tlb.TlbStructToVmCellSlice(domain)
	if err != nil {
		return "", nil, err
	}
	stack.Put(val)
	val = tlb.VmStackValue{SumType: "VmStkInt", VmStkInt: category}
	stack.Put(val)

	// MethodID = 123660 for "dnsresolve" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 123660, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeDnsresolve_RecordResult, DecodeDnsresolve_RecordsResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeDnsresolve_RecordResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 2 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result Dnsresolve_RecordResult
	err = stack.Unmarshal(&result)
	return "Dnsresolve_RecordResult", result, nil
}

func DecodeDnsresolve_RecordsResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 2 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result Dnsresolve_RecordsResult
	err = stack.Unmarshal(&result)
	return "Dnsresolve_RecordsResult", result, nil
}

type GetSaleData_BasicResult struct {
	Marketplace    tlb.MsgAddress
	Nft            tlb.MsgAddress
	Owner          tlb.MsgAddress
	FullPrice      tlb.Int257
	MarketFee      uint64
	RoyaltyAddress tlb.MsgAddress
	RoyaltyAmount  uint64
}

type GetSaleData_GetgemsResult struct {
	Magic            uint64
	IsComplete       bool
	CreatedAt        uint64
	Marketplace      tlb.MsgAddress
	Nft              tlb.MsgAddress
	Owner            tlb.MsgAddress
	FullPrice        tlb.Int257
	MarketFeeAddress tlb.MsgAddress
	MarketFee        uint64
	RoyaltyAddress   tlb.MsgAddress
	RoyaltyAmount    uint64
}

type GetSaleData_GetgemsAuctionResult struct {
	Magic            uint64
	End              bool
	EndTime          uint32
	Marketplace      tlb.MsgAddress
	Nft              tlb.MsgAddress
	Owner            tlb.MsgAddress
	LastBid          uint64
	LastMember       tlb.MsgAddress
	MinStep          uint64
	MarketFeeAddress tlb.MsgAddress
	MpFeeFactor      uint32
	MpFeeBase        uint32
	RoyaltyAddress   tlb.MsgAddress
	RoyaltyFeeFactor uint32
	RoyaltyFeeBase   uint32
	MaxBid           uint64
	MinBid           uint64
	CreatedAt        uint32
	LastBidAt        uint32
	IsCanceled       bool
}

func GetSaleData(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 72748 for "get_sale_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 72748, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetSaleData_BasicResult, DecodeGetSaleData_GetgemsResult, DecodeGetSaleData_GetgemsAuctionResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetSaleData_BasicResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 7 || (stack[0].SumType != "VmStkSlice") || (stack[1].SumType != "VmStkSlice") || (stack[2].SumType != "VmStkSlice") || (stack[3].SumType != "VmStkTinyInt" && stack[3].SumType != "VmStkInt") || (stack[4].SumType != "VmStkTinyInt") || (stack[5].SumType != "VmStkSlice") || (stack[6].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetSaleData_BasicResult
	err = stack.Unmarshal(&result)
	return "GetSaleData_BasicResult", result, nil
}

func DecodeGetSaleData_GetgemsResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 11 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkTinyInt") || (stack[3].SumType != "VmStkSlice") || (stack[4].SumType != "VmStkSlice") || (stack[5].SumType != "VmStkSlice") || (stack[6].SumType != "VmStkTinyInt" && stack[6].SumType != "VmStkInt") || (stack[7].SumType != "VmStkSlice") || (stack[8].SumType != "VmStkTinyInt") || (stack[9].SumType != "VmStkSlice") || (stack[10].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetSaleData_GetgemsResult
	err = stack.Unmarshal(&result)
	return "GetSaleData_GetgemsResult", result, nil
}

func DecodeGetSaleData_GetgemsAuctionResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 20 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkTinyInt") || (stack[3].SumType != "VmStkSlice") || (stack[4].SumType != "VmStkSlice") || (stack[5].SumType != "VmStkSlice") || (stack[6].SumType != "VmStkTinyInt") || (stack[7].SumType != "VmStkSlice") || (stack[8].SumType != "VmStkTinyInt") || (stack[9].SumType != "VmStkSlice") || (stack[10].SumType != "VmStkTinyInt") || (stack[11].SumType != "VmStkTinyInt") || (stack[12].SumType != "VmStkSlice") || (stack[13].SumType != "VmStkTinyInt") || (stack[14].SumType != "VmStkTinyInt") || (stack[15].SumType != "VmStkTinyInt") || (stack[16].SumType != "VmStkTinyInt") || (stack[17].SumType != "VmStkTinyInt") || (stack[18].SumType != "VmStkTinyInt") || (stack[19].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetSaleData_GetgemsAuctionResult
	err = stack.Unmarshal(&result)
	return "GetSaleData_GetgemsAuctionResult", result, nil
}

type GetAuthorityAddressResult struct {
	Address tlb.MsgAddress
}

func GetAuthorityAddress(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 84760 for "get_authority_address" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 84760, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetAuthorityAddressResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetAuthorityAddressResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetAuthorityAddressResult
	err = stack.Unmarshal(&result)
	return "GetAuthorityAddressResult", result, nil
}

type GetRevokedTimeResult struct {
	Time uint64
}

func GetRevokedTime(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 97667 for "get_revoked_time" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 97667, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetRevokedTimeResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetRevokedTimeResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetRevokedTimeResult
	err = stack.Unmarshal(&result)
	return "GetRevokedTimeResult", result, nil
}

type GetChannelStateResult struct {
	State uint64
}

func GetChannelState(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 106901 for "get_channel_state" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 106901, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetChannelStateResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetChannelStateResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetChannelStateResult
	err = stack.Unmarshal(&result)
	return "GetChannelStateResult", result, nil
}

type GetWalletParamsResult struct {
	Seqno     uint32
	Subwallet uint32
	PublicKey tlb.Int257
}

func GetWalletParams(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 130271 for "get_wallet_params" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 130271, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetWalletParamsResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetWalletParamsResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 3 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkTinyInt" && stack[2].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetWalletParamsResult
	err = stack.Unmarshal(&result)
	return "GetWalletParamsResult", result, nil
}

type GetStorageParamsResult struct {
	AcceptNewContracts bool
	RatePerMbDay       uint64
	MaxSpan            uint32
	MinimalFileSize    uint64
	MaximalFileSize    uint64
}

func GetStorageParams(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 104346 for "get_storage_params" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 104346, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetStorageParamsResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetStorageParamsResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 5 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkTinyInt") || (stack[3].SumType != "VmStkTinyInt") || (stack[4].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetStorageParamsResult
	err = stack.Unmarshal(&result)
	return "GetStorageParamsResult", result, nil
}

type GetStorageContractAddressResult struct {
	StorageContractAddress tlb.MsgAddress
}

func GetStorageContractAddress(ctx context.Context, executor Executor, reqAccountID tongo.AccountID, merkleHash tlb.Int257, fileSize uint64, client tlb.MsgAddress, torrentHash tlb.Int257) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val = tlb.VmStackValue{SumType: "VmStkInt", VmStkInt: merkleHash}
	stack.Put(val)
	val = tlb.VmStackValue{SumType: "VmStkTinyInt", VmStkTinyInt: int64(fileSize)}
	stack.Put(val)
	val, err = tlb.TlbStructToVmCellSlice(client)
	if err != nil {
		return "", nil, err
	}
	stack.Put(val)
	val = tlb.VmStackValue{SumType: "VmStkInt", VmStkInt: torrentHash}
	stack.Put(val)

	// MethodID = 119729 for "get_storage_contract_address" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 119729, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetStorageContractAddressResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetStorageContractAddressResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetStorageContractAddressResult
	err = stack.Unmarshal(&result)
	return "GetStorageContractAddressResult", result, nil
}

type GetStorageContractDataResult struct {
	Active        bool
	Balance       uint64
	Provider      tlb.MsgAddress
	MerkleHash    tlb.Int257
	FileSize      uint64
	NextProof     uint64
	RatePerMbDay  uint64
	MaxSpan       uint32
	LastProofTime uint32
	Client        tlb.MsgAddress
	TorrentHash   tlb.Int257
}

func GetStorageContractData(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 86593 for "get_storage_contract_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 86593, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetStorageContractDataResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetStorageContractDataResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 11 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkSlice") || (stack[3].SumType != "VmStkTinyInt" && stack[3].SumType != "VmStkInt") || (stack[4].SumType != "VmStkTinyInt") || (stack[5].SumType != "VmStkTinyInt") || (stack[6].SumType != "VmStkTinyInt") || (stack[7].SumType != "VmStkTinyInt") || (stack[8].SumType != "VmStkTinyInt") || (stack[9].SumType != "VmStkSlice") || (stack[10].SumType != "VmStkTinyInt" && stack[10].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetStorageContractDataResult
	err = stack.Unmarshal(&result)
	return "GetStorageContractDataResult", result, nil
}

type GetTorrentHashResult struct {
	TorrentHash tlb.Int257
}

func GetTorrentHash(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 71463 for "get_torrent_hash" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 71463, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetTorrentHashResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetTorrentHashResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTinyInt" && stack[0].SumType != "VmStkInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetTorrentHashResult
	err = stack.Unmarshal(&result)
	return "GetTorrentHashResult", result, nil
}

type IsActiveResult struct {
	IsActive bool
}

func IsActive(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 122058 for "is_active" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 122058, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeIsActiveResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeIsActiveResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result IsActiveResult
	err = stack.Unmarshal(&result)
	return "IsActiveResult", result, nil
}

type GetNextProofInfoResult struct {
	NextProof     uint64
	LastProofTime uint32
	MaxSpan       uint32
}

func GetNextProofInfo(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 81490 for "get_next_proof_info" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 81490, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetNextProofInfoResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetNextProofInfoResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 3 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetNextProofInfoResult
	err = stack.Unmarshal(&result)
	return "GetNextProofInfoResult", result, nil
}

type ListNominatorsResult struct {
	Nominators []struct {
		Address              tlb.Bits256
		Amount               uint64
		PendingDepositAmount uint64
		WithdrawRequested    bool
	}
}

func ListNominators(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 111161 for "list_nominators" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 111161, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeListNominatorsResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeListNominatorsResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTuple" && stack[0].SumType != "VmStkNull") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result ListNominatorsResult
	err = stack.Unmarshal(&result)
	return "ListNominatorsResult", result, nil
}

type ListVotesResult struct {
	Votes []struct {
		ProposalHash   tlb.Bits256
		VoteCreateTime uint32
	}
}

func ListVotes(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 130309 for "list_votes" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 130309, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeListVotesResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeListVotesResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 1 || (stack[0].SumType != "VmStkTuple" && stack[0].SumType != "VmStkNull") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result ListVotesResult
	err = stack.Unmarshal(&result)
	return "ListVotesResult", result, nil
}

type GetPoolData_TfResult struct {
	State                int8
	NominatorsCount      uint32
	StakeAmountSent      int64
	ValidatorAmount      int64
	ValidatorAddress     tlb.Bits256
	ValidatorRewardShare uint32
	MaxNominatorsCount   uint32
	MinValidatorStake    int64
	MinNominatorStake    int64
	Nominators           tlb.Any
	WithdrawRequests     []struct {
	}

	StakeAt                  uint32
	SavedValidatorSetHash    tlb.Bits256
	ValidatorSetChangesCount uint32
	ValidatorSetChangeTime   uint32
	StakeHeldFor             uint32
	ConfigProposalVotings    []struct {
	}
}

func GetPoolData(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 81689 for "get_pool_data" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 81689, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetPoolData_TfResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetPoolData_TfResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 17 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkTinyInt") || (stack[3].SumType != "VmStkTinyInt") || (stack[4].SumType != "VmStkTinyInt" && stack[4].SumType != "VmStkInt") || (stack[5].SumType != "VmStkTinyInt") || (stack[6].SumType != "VmStkTinyInt") || (stack[7].SumType != "VmStkTinyInt") || (stack[8].SumType != "VmStkTinyInt") || (stack[9].SumType != "VmStkCell") || (stack[10].SumType != "VmStkTuple" && stack[10].SumType != "VmStkNull") || (stack[11].SumType != "VmStkTinyInt") || (stack[12].SumType != "VmStkTinyInt" && stack[12].SumType != "VmStkInt") || (stack[13].SumType != "VmStkTinyInt") || (stack[14].SumType != "VmStkTinyInt") || (stack[15].SumType != "VmStkTinyInt") || (stack[16].SumType != "VmStkTuple" && stack[16].SumType != "VmStkNull") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetPoolData_TfResult
	err = stack.Unmarshal(&result)
	return "GetPoolData_TfResult", result, nil
}

type GetStakingStatusResult struct {
	StakeAt             uint32
	StakeUntil          uint32
	StakeSent           uint64
	QuerySent           bool
	CouldUnlock         bool
	Locked              bool
	ProxyStakeLockFinal bool
}

func GetStakingStatus(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 123928 for "get_staking_status" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 123928, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetStakingStatusResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetStakingStatusResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 7 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkTinyInt") || (stack[3].SumType != "VmStkTinyInt") || (stack[4].SumType != "VmStkTinyInt") || (stack[5].SumType != "VmStkTinyInt") || (stack[6].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetStakingStatusResult
	err = stack.Unmarshal(&result)
	return "GetStakingStatusResult", result, nil
}

type GetPoolStatusResult struct {
	Balance                int64
	BalanceSent            int64
	BalancePendingDeposits int64
	BalancePendingWithdraw int64
	BalanceWithdraw        int64
}

func GetPoolStatus(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 120146 for "get_pool_status" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 120146, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetPoolStatusResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetPoolStatusResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 5 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkTinyInt") || (stack[3].SumType != "VmStkTinyInt") || (stack[4].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetPoolStatusResult
	err = stack.Unmarshal(&result)
	return "GetPoolStatusResult", result, nil
}

type GetMember_WhalesNominatorResult struct {
	MemberBalance         int64
	MemberPendingDeposit  int64
	MemberPendingWithdraw int64
	MemberWithdraw        int64
}

func GetMember(ctx context.Context, executor Executor, reqAccountID tongo.AccountID, member tlb.MsgAddress) (string, any, error) {
	stack := tlb.VmStack{}
	var (
		val tlb.VmStackValue
		err error
	)
	val, err = tlb.TlbStructToVmCellSlice(member)
	if err != nil {
		return "", nil, err
	}
	stack.Put(val)

	// MethodID = 70558 for "get_member" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 70558, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetMember_WhalesNominatorResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetMember_WhalesNominatorResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) < 4 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkTinyInt") || (stack[3].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetMember_WhalesNominatorResult
	err = stack.Unmarshal(&result)
	return "GetMember_WhalesNominatorResult", result, nil
}

type GetMembersRaw_WhalesNominatorResult struct {
	Members WhalesNominatorsMembersList
}

func GetMembersRaw(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 89295 for "get_members_raw" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 89295, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetMembersRaw_WhalesNominatorResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetMembersRaw_WhalesNominatorResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 1 || (stack[0].SumType != "VmStkCell") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetMembersRaw_WhalesNominatorResult
	err = stack.Unmarshal(&result)
	return "GetMembersRaw_WhalesNominatorResult", result, nil
}

type GetParams_WhalesNominatorResult struct {
	Enabled        bool
	UpdatesEnables bool
	MinStake       int64
	DepositFee     int64
	WithdrawFee    int64
	PoolFee        int64
	ReceiptPrice   int64
}

func GetParams(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 115150 for "get_params" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 115150, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetParams_WhalesNominatorResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetParams_WhalesNominatorResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 7 || (stack[0].SumType != "VmStkTinyInt") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkTinyInt") || (stack[3].SumType != "VmStkTinyInt") || (stack[4].SumType != "VmStkTinyInt") || (stack[5].SumType != "VmStkTinyInt") || (stack[6].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetParams_WhalesNominatorResult
	err = stack.Unmarshal(&result)
	return "GetParams_WhalesNominatorResult", result, nil
}

type GetTelemintAuctionStateResult struct {
	Bidder  tlb.MsgAddress
	Bid     int64
	BidTs   int64
	MinBid  int64
	EndTime int64
}

func GetTelemintAuctionState(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 122498 for "get_telemint_auction_state" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 122498, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetTelemintAuctionStateResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetTelemintAuctionStateResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 5 || (stack[0].SumType != "VmStkSlice") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkTinyInt") || (stack[3].SumType != "VmStkTinyInt") || (stack[4].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetTelemintAuctionStateResult
	err = stack.Unmarshal(&result)
	return "GetTelemintAuctionStateResult", result, nil
}

type GetTelemintAuctionConfigResult struct {
	Beneficiar    tlb.MsgAddress
	InitialMinBid int64
	MaxBid        int64
	MinBidStep    int64
	MinExtendTime int64
	Duration      int64
}

func GetTelemintAuctionConfig(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 129619 for "get_telemint_auction_config" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 129619, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetTelemintAuctionConfigResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetTelemintAuctionConfigResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 6 || (stack[0].SumType != "VmStkSlice") || (stack[1].SumType != "VmStkTinyInt") || (stack[2].SumType != "VmStkTinyInt") || (stack[3].SumType != "VmStkTinyInt") || (stack[4].SumType != "VmStkTinyInt") || (stack[5].SumType != "VmStkTinyInt") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetTelemintAuctionConfigResult
	err = stack.Unmarshal(&result)
	return "GetTelemintAuctionConfigResult", result, nil
}

type GetTelemintTokenNameResult struct {
	Beneficiar tlb.Text
}

func GetTelemintTokenName(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error) {
	stack := tlb.VmStack{}

	// MethodID = 69506 for "get_telemint_token_name" method
	errCode, stack, err := executor.RunSmcMethodByID(ctx, reqAccountID, 69506, stack)
	if err != nil {
		return "", nil, err
	}
	if errCode != 0 && errCode != 1 {
		return "", nil, fmt.Errorf("method execution failed with code: %v", errCode)
	}
	for _, f := range []func(tlb.VmStack) (string, any, error){DecodeGetTelemintTokenNameResult} {
		s, r, err := f(stack)
		if err == nil {
			return s, r, nil
		}
	}
	return "", nil, fmt.Errorf("can not decode outputs")
}

func DecodeGetTelemintTokenNameResult(stack tlb.VmStack) (resultType string, resultAny any, err error) {
	if len(stack) != 1 || (stack[0].SumType != "VmStkSlice") {
		return "", nil, fmt.Errorf("invalid stack format")
	}
	var result GetTelemintTokenNameResult
	err = stack.Unmarshal(&result)
	return "GetTelemintTokenNameResult", result, nil
}

type ContractInterface string

// more wallet-related contract interfaces are defined in wallet.go
const (
	NftSale          ContractInterface = "nft_sale"
	NftSaleGetgems   ContractInterface = "nft_sale_getgems"
	PaymentChannel   ContractInterface = "payment_channel"
	StorageContract  ContractInterface = "storage_contract"
	StorageProvider  ContractInterface = "storage_provider"
	Telemint         ContractInterface = "telemint"
	Tep62Collection  ContractInterface = "tep62_collection"
	Tep62Item        ContractInterface = "tep62_item"
	Tep66            ContractInterface = "tep66"
	Tep74            ContractInterface = "tep74"
	Tep85            ContractInterface = "tep85"
	TfNominator      ContractInterface = "tf_nominator"
	Wallet           ContractInterface = "wallet"
	WalletV4R2       ContractInterface = "wallet_v4r2"
	WhalesNominators ContractInterface = "whales_nominators"
)

type InvokeFn func(ctx context.Context, executor Executor, reqAccountID tongo.AccountID) (string, any, error)

// MethodDescription describes a particular method and provides a function to execute it.
type MethodDescription struct {
	Name string
	// InvokeFn executes this method on a contract and returns parsed execution results.
	InvokeFn InvokeFn
	// ImplementedBy is a list of contract interfaces that implement this method.
	// All contract interfaces share the same method with the same output type.
	ImplementedBy []ContractInterface
	// ImplementedByFn returns an implemented contract interface based on a type hint from InvokeFn.
	// Contract interfaces share the same method name but output is different for each contract interface.
	// Check GetSaleData out as an example.
	ImplementedByFn func(typeName string) ContractInterface
}

var methodInvocationOrder = []MethodDescription{
	{
		Name:          "get_authority_address",
		InvokeFn:      GetAuthorityAddress,
		ImplementedBy: []ContractInterface{Tep85},
	},
	{
		Name:          "get_channel_state",
		InvokeFn:      GetChannelState,
		ImplementedBy: []ContractInterface{PaymentChannel},
	},
	{
		Name:          "get_collection_data",
		InvokeFn:      GetCollectionData,
		ImplementedBy: []ContractInterface{Tep62Collection},
	},
	{
		Name:          "get_jetton_data",
		InvokeFn:      GetJettonData,
		ImplementedBy: []ContractInterface{Tep74},
	},
	{
		Name:     "get_members_raw",
		InvokeFn: GetMembersRaw,
		ImplementedByFn: func(typeHint string) ContractInterface {
			switch typeHint {
			case "GetMembersRaw_WhalesNominatorResult":
				return WhalesNominators
			}
			return ""
		},
	},
	{
		Name:          "get_next_proof_info",
		InvokeFn:      GetNextProofInfo,
		ImplementedBy: []ContractInterface{StorageContract},
	},
	{
		Name:          "get_nft_data",
		InvokeFn:      GetNftData,
		ImplementedBy: []ContractInterface{Tep62Item},
	},
	{
		Name:     "get_params",
		InvokeFn: GetParams,
		ImplementedByFn: func(typeHint string) ContractInterface {
			switch typeHint {
			case "GetParams_WhalesNominatorResult":
				return WhalesNominators
			}
			return ""
		},
	},
	{
		Name:          "get_plugin_list",
		InvokeFn:      GetPluginList,
		ImplementedBy: []ContractInterface{WalletV4R2},
	},
	{
		Name:          "get_pool_data",
		InvokeFn:      GetPoolData,
		ImplementedBy: []ContractInterface{TfNominator},
	},
	{
		Name:          "get_pool_status",
		InvokeFn:      GetPoolStatus,
		ImplementedBy: []ContractInterface{WhalesNominators},
	},
	{
		Name:          "get_public_key",
		InvokeFn:      GetPublicKey,
		ImplementedBy: []ContractInterface{StorageProvider, Wallet},
	},
	{
		Name:          "get_revoked_time",
		InvokeFn:      GetRevokedTime,
		ImplementedBy: []ContractInterface{Tep85},
	},
	{
		Name:     "get_sale_data",
		InvokeFn: GetSaleData,
		ImplementedByFn: func(typeHint string) ContractInterface {
			switch typeHint {
			case "GetSaleData_BasicResult":
				return NftSale
			case "GetSaleData_GetgemsAuctionResult":
				return NftSaleGetgems
			case "GetSaleData_GetgemsResult":
				return NftSaleGetgems
			}
			return ""
		},
	},
	{
		Name:          "get_staking_status",
		InvokeFn:      GetStakingStatus,
		ImplementedBy: []ContractInterface{WhalesNominators},
	},
	{
		Name:          "get_storage_contract_data",
		InvokeFn:      GetStorageContractData,
		ImplementedBy: []ContractInterface{StorageContract},
	},
	{
		Name:          "get_storage_params",
		InvokeFn:      GetStorageParams,
		ImplementedBy: []ContractInterface{StorageProvider},
	},
	{
		Name:          "get_subwallet_id",
		InvokeFn:      GetSubwalletId,
		ImplementedBy: []ContractInterface{WalletV4R2},
	},
	{
		Name:          "get_telemint_auction_config",
		InvokeFn:      GetTelemintAuctionConfig,
		ImplementedBy: []ContractInterface{Telemint},
	},
	{
		Name:          "get_telemint_auction_state",
		InvokeFn:      GetTelemintAuctionState,
		ImplementedBy: []ContractInterface{Telemint},
	},
	{
		Name:          "get_telemint_token_name",
		InvokeFn:      GetTelemintTokenName,
		ImplementedBy: []ContractInterface{Telemint},
	},
	{
		Name:          "get_torrent_hash",
		InvokeFn:      GetTorrentHash,
		ImplementedBy: []ContractInterface{StorageContract},
	},
	{
		Name:          "get_wallet_data",
		InvokeFn:      GetWalletData,
		ImplementedBy: []ContractInterface{Tep74},
	},
	{
		Name:          "get_wallet_params",
		InvokeFn:      GetWalletParams,
		ImplementedBy: []ContractInterface{StorageProvider},
	},
	{
		Name:          "is_active",
		InvokeFn:      IsActive,
		ImplementedBy: []ContractInterface{StorageContract},
	},
	{
		Name:          "list_nominators",
		InvokeFn:      ListNominators,
		ImplementedBy: []ContractInterface{TfNominator},
	},
	{
		Name:          "list_votes",
		InvokeFn:      ListVotes,
		ImplementedBy: []ContractInterface{TfNominator},
	},
	{
		Name:          "royalty_params",
		InvokeFn:      RoyaltyParams,
		ImplementedBy: []ContractInterface{Tep66},
	},
	{
		Name:          "seqno",
		InvokeFn:      Seqno,
		ImplementedBy: []ContractInterface{StorageProvider, Wallet},
	},
}
