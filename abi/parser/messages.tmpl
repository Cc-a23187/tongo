func pointer[T any](t T) *T{
	return &t
}

var messagesDecodingFunctions =map[uint32]func(cell *boc.Cell)  ( *MsgOpName, any, error) {
{{- range $tag, $ops := .Operations }}
            {{- if gt (len $ops) 1 }}
            // {{- range $op := $ops}}{{ $op.OperationName }}, {{ end }}
                0x{{ printf "%08x" $tag }}: func(cell *boc.Cell) (*MsgOpName, any, error) {
                var err error
                cell = cell.CopyRemaining()
            {{- else }}
                {{- $op := index $ops 0 }}
                // 0x{{ printf "%08x" $op.Tag }}
                {{ $op.OperationName }}MsgOpCode: func(cell *boc.Cell) (*MsgOpName, any, error) {
                var err error
            {{- end }}
            {{- range $op := $ops }}
                var res{{ $op.TypeName }} {{ $op.TypeName }}
                err = tlb.Unmarshal(cell, &res{{ $op.TypeName }})
               {{- if $op.FixedLength }}
                if err == nil  && !completedRead(cell) { err = ErrStructSizeMismatch ;}
                {{- end }}
               if err == nil {
                    return  pointer({{ $op.OperationName }}MsgOp), res{{ $op.TypeName }}, nil;
                }
                cell.ResetCounters()
            {{- end }}
            return nil, nil, err
            },
        {{- end }}
}

// MessageDecoder takes in a message body as a cell and tries to decode it based on the first 4 bytes.
// It returns an opcode, an operation name and a decoded body.
func InternalMessageDecoder(cell *boc.Cell, interfaces []ContractInterface) (*uint32, *MsgOpName, any, error) {
	if cell.BitsAvailableForRead() < 32 {
		return nil, nil, nil, nil
	}
	tag64, err := cell.ReadUint(32)
	if err != nil {
		return nil, nil, nil,err
	}
	tag := uint32(tag64)
	f := messagesDecodingFunctions[tag]
    if f != nil {
        name, a, err := f(cell)
        return &tag, name, a, err
    }
    return &tag, nil, nil, nil
}

func completedRead(cell *boc.Cell) bool {
   return cell.RefsAvailableForRead() == 0 && cell.BitsAvailableForRead() == 0
}

// MsgOpName is a human-friendly name for a message's operation which is identified by the first 4 bytes of the message's body.
type MsgOpName = string
const (
{{- range  $tag, $ops := .Operations }}
    {{- range $op := $ops}}
       {{ $op.OperationName }}MsgOp MsgOpName = "{{ $op.OperationName }}"
    {{- end }}
{{- end }}
)
// MsgOpCode is the first 4 bytes of a message body identifying an operation to be performed.
type MsgOpCode = uint32
const (
{{- range  $tag, $ops := .Operations }}
    {{- range $op := $ops}}
       {{ $op.OperationName }}MsgOpCode MsgOpCode = 0x{{ printf "%08x" $op.Tag }}
   {{- end }}
{{- end }}
)

var KnownMsgTypes = map[string]any{
{{- range  $tag, $ops := .Operations }}
    {{- range $op := $ops}}
       {{ $op.OperationName }}MsgOp: {{ $op.TypeName }}{},
    {{- end }}
{{- end }}
}