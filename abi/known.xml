<interfaces>

    <!--    Text    -->
    <interface name="text_comment" group="text">
        <internal name="text_comment">
            <input>
                text_comment#00000000 text:Text = InternalMsgBody;
            </input>
        </internal>
    </interface>

    <!--    NFT item    -->
    <interface name="tep_62_nft_item" group="nft">
        <get_method name="get_nft_data" callback="true">
            <output>
                <tinyint name="init">int8</tinyint>
                <int name="index">int257</int>
                <slice name="collection_address">AccountID</slice>
                <slice name="owner_address">AccountID</slice>
                <cell name="individual_content">any</cell>
            </output>
        </get_method>
        <internal name="transfer">
            <input>
                transfer#5fcc3d14 query_id:uint64 new_owner:MsgAddress response_destination:MsgAddress
                custom_payload:(Maybe ^Cell) forward_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell) =
                InternalMsgBody;
            </input>
            <output>
                ownership_assigned#05138d91 query_id:uint64 prev_owner:MsgAddress forward_payload:(Either Cell ^Cell) =
                InternalMsgBody;
            </output>
            <output>
                excesses#d53276db query_id:uint64 = InternalMsgBody;
            </output>
        </internal>
        <internal name="get_static_data">
            <input>
                get_static_data#2fcb26a2 query_id:uint64 = InternalMsgBody;
            </input>
            <output>
                report_static_data#8b771735 query_id:uint64 index:uint256 collection:MsgAddress = InternalMsgBody;
            </output>
        </internal>
    </interface>

    <!--    NFT collection    -->
    <interface name="tep_62_nft_collection" group="nft">
        <types>
            snake#00 data:(SnakeData ~n) = ContentData;
            chunks#01 data:ChunkedData = ContentData;
            onchain#00 data:(HashmapE 256 ^ContentData) = FullContent;
            offchain#01 uri:Text = FullContent;
        </types>
        <get_method name="get_nft_content">
            <input>
                <int name="index">int257</int>
                <cell name="individual_content">any</cell>
            </input>
            <output>
                <cell name="content">FullContent</cell>
            </output>
        </get_method>
        <get_method name="get_collection_data">
            <output>
                <int name="next_item_index">int257</int>
                <cell name="collection_content">any</cell>
                <slice name="owner_address">AccountID</slice>
            </output>
        </get_method>
        <get_method name="get_nft_address_by_index">
            <input>
                <int name="index">int257</int>
            </input>
            <output>
                <slice name="address">AccountID</slice>
            </output>
        </get_method>
    </interface>

    <!--    NFT royalty    -->
    <interface name="tep_66_nft_royalty" group="nft">
        <get_method name="royalty_params">
            <output>
                <tinyint name="numerator">uint16</tinyint>
                <tinyint name="denominator">uint16</tinyint>
                <slice name="destination">AccountID</slice>
            </output>
        </get_method>
        <internal name="get_royalty_params">
            <input>
                get_royalty_params#693d3950 query_id:uint64 = InternalMsgBody;
            </input>
            <output>
                report_royalty_params#a8cb00ad query_id:uint64 numerator:uint16 denominator:uint16 destination:MsgAddress = InternalMsgBody;
            </output>
        </internal>
    </interface>

    <!--    Jetton master    -->
    <interface name="tep_74_jetton_master" group="jetton">
        <get_method name="get_jetton_data">
            <output>
                <int name="total_supply">int257</int>
                <tinyint name="mintable">int8</tinyint>
                <slice name="admin_address">AccountID</slice>
                <cell name="jetton_content">any</cell>
                <cell name="jetton_wallet_code">any</cell>
            </output>
        </get_method>
        <get_method name="get_wallet_address">
            <input>
                <slice name="owner_address">AccountID</slice>
            </input>
            <output>
                <slice name="jetton_wallet_address">AccountID</slice>
            </output>
        </get_method>
    </interface>

    <!--    Jetton wallet    -->
    <interface name="tep_74_jetton_wallet" group="jetton">
        <get_method name="get_wallet_data">
            <output>
                <int name="balance">int257</int>
                <slice name="owner">AccountID</slice>
                <slice name="jetton">AccountID</slice>
                <cell name="jetton_wallet_code">any</cell>
            </output>
        </get_method>
        <internal name="transfer">
            <input>
                transfer#0f8a7ea5 query_id:uint64 amount:(VarUInteger 16) destination:MsgAddress
                response_destination:MsgAddress custom_payload:(Maybe ^Cell)
                forward_ton_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell)
                = InternalMsgBody;
            </input>
            <output>
                transfer_notification#7362d09c query_id:uint64 amount:(VarUInteger 16)
                sender:MsgAddress forward_payload:(Either Cell ^Cell)
                = InternalMsgBody;
            </output>
            <output>
                excesses#d53276db query_id:uint64 = InternalMsgBody;
            </output>
        </internal>
        <internal name="burn">
            <input>
                burn#595f07bc query_id:uint64 amount:(VarUInteger 16)
                response_destination:MsgAddress custom_payload:(Maybe ^Cell)
                = InternalMsgBody;
            </input>
            <output>
                excesses#d53276db query_id:uint64 = InternalMsgBody;
            </output>
        </internal>
    </interface>

    <!--    DNS    -->
    <interface name="tep_81_dns" group="dns">
        <get_method name="dnsresolve">
            <input>
                <slice name="domain">[]byte</slice>
                <int name="category">int257</int>
            </input>
            <output version="record" fixed_length="true">
                <tinyint name="resolved_bits">int64</tinyint>
                <cell name="result">DNSRecord</cell>
            </output>
            <output version="records" fixed_length="true">
                <tinyint name="resolved_bits">int64</tinyint>
                <cell name="result">DNS_RecordSet</cell>
            </output>
        </get_method>
    </interface>

    <!--    NFT sale    -->
    <interface name="nft_sale" group="nft">
        <get_method name="get_sale_data">
            <output version="basic" fixed_length="true">
                <slice name="marketplace">AccountID</slice>
                <slice name="nft">AccountID</slice>
                <slice name="owner">AccountID</slice>
                <int name="full_price">int257</int>
                <tinyint name="market_fee">uint64</tinyint>
                <slice name="royalty_address">AccountID</slice>
                <tinyint name="royalty_amount">uint64</tinyint>
            </output>
            <output version="getgems" fixed_length="true">
                <tinyint name="fix_price">uint64</tinyint>
                <tinyint name="is_complete">bool</tinyint>
                <tinyint name="created_at">uint64</tinyint>
                <slice name="marketplace">AccountID</slice>
                <slice name="nft">AccountID</slice>
                <slice name="owner">AccountID</slice>
                <int name="full_price">int257</int>
                <slice name="market_fee_address">AccountID</slice>
                <tinyint name="market_fee">uint64</tinyint>
                <slice name="royalty_address">AccountID</slice>
                <tinyint name="royalty_amount">uint64</tinyint>
            </output>
        </get_method>
    </interface>
    
    <!--    SBT    -->
    <interface name="tep_85_sbt" group="sbt">
        <get_method name="get_authority_address">
            <output>
                <slice name="address">AccountID</slice>
            </output>
        </get_method>
        <get_method name="get_revoked_time">
            <output>
                <tinyint name="time">uint64</tinyint>
            </output>
        </get_method>
        <internal name="prove_ownership">
            <input>
                prove_ownership#04ded148 query_id:uint64 dest:MsgAddress
                forward_payload:^Cell with_content:Bool = InternalMsgBody;
            </input>
            <output>
                ownership_proof#0524c7ae query_id:uint64 item_id:uint256 owner:MsgAddress
                data:^Cell revoked_at:uint64 content:(Maybe ^Cell) = InternalMsgBody;
            </output>
        </internal>
        <internal name="request_owner">
            <input>
                request_owner#d0c3bfea query_id:uint64 dest:MsgAddress
                forward_payload:^Cell with_content:Bool = InternalMsgBody;
            </input>
            <output>
                owner_info#0dd607e3 query_id:uint64 item_id:uint256 initiator:MsgAddress owner:MsgAddress
                data:^Cell revoked_at:uint64 content:(Maybe ^Cell) = InternalMsgBody;
            </output>
        </internal>
        <internal name="destroy">
            <input>
                destroy#1f04537a query_id:uint64 = InternalMsgBody;
            </input>
            <output>
                excesses#d53276db query_id:uint64 = InternalMsgBody;
            </output>
        </internal>
        <internal name="revoke">
            <input>
                revoke#6f89f5e3 query_id:uint64 = InternalMsgBody;
            </input>
        </internal>
    </interface>

    <!--    Payment channel    -->
    <interface name="payment_channel" group="payment_channel">
        <types>
            cp#_ amount:Coins condition:Cell = ConditionalPayment;
            sc_body#_ seqno:uint64 sent:Coins conditionals:(HashmapE 32 ConditionalPayment)
            = SemiChannelBody; // 64+132+1 = 197
            semichannel_state#43685374 channel_id:uint128 data:SemiChannelBody counterparty_data:(Maybe ^SemiChannelBody)
            = SemiChannel; // 32 + 128 + 197 + 1 = 358
            signed_schs#_ signature:bits512 state:SemiChannel = SignedSemiChannel; // 512 + 358 = 870
            quarantined_state#_ state_A:SemiChannelBody state_B:SemiChannelBody
            quarantine_starts:uint32
            state_commited_by_A:Bool
            = QuarantinedState; // 358 + 358 + 32 + 1 = 749
            conf#_ quarantin_duration:uint32
            misbehavior_fine:Coins
            conditional_close_duration:uint32 = ClosingConfig; // 32 + 132 + 132 + 32 = 296
            payment_conf#_  excess_fee:Coins
            dest_A:MsgAddress
            dest_B:MsgAddress = PaymentConfig;
            channel_state#_ balance_A:Coins balance_B:Coins
            key_A:uint256 key_B:uint256
            channel_id:uint128
            config:^ClosingConfig
            commited_seqno_A:uint32 commited_seqno_B:uint32
            quarantin:(Maybe ^QuarantinedState)
            payments:^PaymentConfig = Storage;
            // 132 + 132 + 256 + 256 + 32 + 32 + 1 + 132 = 973
        </types>
        <get_method name="get_channel_state">
            <output>
                <tinyint name="state">uint64</tinyint>
            </output>
        </get_method>
<!--        <get_method name="get_channel_data">-->
<!--            <output>-->
<!--            </output>-->
<!--        </get_method>-->
        <internal name="top_up_balance">
            <input>
                top_up_balance#67c7d281 add_A:Coins add_B:Coins = InternalMsgBody;
            </input>
        </internal>
        <internal name="init_channel">
            <input>
                init_channel#56103bba is_A:Bool signature:bits512 tag:# channel_id:uint128 balance_A:Coins balance_B:Coins = InternalMsgBody;
            </input>
        </internal>
        <internal name="cooperative_close">
            <input>
                cooperative_close#0df395b9 sig_A:^bits512 sig_B:^bits512 tag:# channel_id:uint128 balance_A:Coins balance_B:Coins seqno_A:uint64 seqno_B:uint64 = InternalMsgBody;
            </input>
        </internal>
        <internal name="cooperative_commit">
            <input>
                cooperative_commit#cf19aff5 sig_A:^bits512 sig_B:^bits512 tag:# channel_id:uint128 seqno_A:uint64 seqno_B:uint64 = InternalMsgBody;
            </input>
        </internal>
        <internal name="start_uncooperative_close">
            <input>
                start_uncooperative_close#b942f428 signed_by_A:Bool signature:bits512 tag:# channel_id:uint128
                sch_A:^SignedSemiChannel
                sch_B:^SignedSemiChannel = InternalMsgBody;
            </input>
        </internal>
        <internal name="challenge_quarantined_state">
            <input>
                challenge_quarantined_state#ab15bc6a
                challenged_by_A:Bool signature:bits512 tag:# channel_id:uint128
                sch_A:^SignedSemiChannel
                sch_B:^SignedSemiChannel = InternalMsgBody;
            </input>
        </internal>
        <internal name="settle_conditionals">
            <input>
                settle_conditionals#04291097
                from_A:Bool signature:bits512 tag:# channel_id:uint128
                conditionals_to_settle:(HashmapE 32 Cell)
                = InternalMsgBody;
            </input>
        </internal>
        <internal name="finish_uncooperative_close">
            <input>
                finish_uncooperative_close#25432a91 = InternalMsgBody;
            </input>
        </internal>
        <internal name="channel_closed">
            <input>
                channel_closed#dddc88ba channel_id:uint128 = InternalMsgBody;
            </input>
        </internal>
    </interface>
</interfaces>